<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/louischatriot/nedb"

    >nedb (v1.8.0)</a>
</h1>
<h4>File-based embedded data store for node.js</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.nedb">module nedb</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.nedb">
            function <span class="apidocSignatureSpan"></span>nedb
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.cursor">
            function <span class="apidocSignatureSpan">nedb.</span>cursor
            <span class="apidocSignatureSpan">(db, query, execFn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.datastore">
            function <span class="apidocSignatureSpan">nedb.</span>datastore
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.executor">
            function <span class="apidocSignatureSpan">nedb.</span>executor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.persistence">
            function <span class="apidocSignatureSpan">nedb.</span>persistence
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.super_">
            function <span class="apidocSignatureSpan">nedb.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">nedb.</span>commonUtilities</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">nedb.</span>cursor.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">nedb.</span>customUtils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">nedb.</span>datastore.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">nedb.</span>executor.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">nedb.</span>model</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">nedb.</span>persistence.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">nedb.</span>storage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nedb.commonUtilities">module nedb.commonUtilities</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.commonUtilities.findDocs">
            function <span class="apidocSignatureSpan">nedb.commonUtilities.</span>findDocs
            <span class="apidocSignatureSpan">(d, n, profiler, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.commonUtilities.findDocsWithIn">
            function <span class="apidocSignatureSpan">nedb.commonUtilities.</span>findDocsWithIn
            <span class="apidocSignatureSpan">(d, n, profiler, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.commonUtilities.findOneDocs">
            function <span class="apidocSignatureSpan">nedb.commonUtilities.</span>findOneDocs
            <span class="apidocSignatureSpan">(d, n, profiler, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.commonUtilities.getConfiguration">
            function <span class="apidocSignatureSpan">nedb.commonUtilities.</span>getConfiguration
            <span class="apidocSignatureSpan">(benchDb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.commonUtilities.getRandomArray">
            function <span class="apidocSignatureSpan">nedb.commonUtilities.</span>getRandomArray
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.commonUtilities.insertDocs">
            function <span class="apidocSignatureSpan">nedb.commonUtilities.</span>insertDocs
            <span class="apidocSignatureSpan">(d, n, profiler, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.commonUtilities.loadDatabase">
            function <span class="apidocSignatureSpan">nedb.commonUtilities.</span>loadDatabase
            <span class="apidocSignatureSpan">(d, n, profiler, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.commonUtilities.prepareDb">
            function <span class="apidocSignatureSpan">nedb.commonUtilities.</span>prepareDb
            <span class="apidocSignatureSpan">(filename, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.commonUtilities.removeDocs">
            function <span class="apidocSignatureSpan">nedb.commonUtilities.</span>removeDocs
            <span class="apidocSignatureSpan">(options, d, n, profiler, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.commonUtilities.updateDocs">
            function <span class="apidocSignatureSpan">nedb.commonUtilities.</span>updateDocs
            <span class="apidocSignatureSpan">(options, d, n, profiler, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nedb.cursor">module nedb.cursor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.cursor.cursor">
            function <span class="apidocSignatureSpan">nedb.</span>cursor
            <span class="apidocSignatureSpan">(db, query, execFn)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nedb.cursor.prototype">module nedb.cursor.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.cursor.prototype._exec">
            function <span class="apidocSignatureSpan">nedb.cursor.prototype.</span>_exec
            <span class="apidocSignatureSpan">(_callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.cursor.prototype.exec">
            function <span class="apidocSignatureSpan">nedb.cursor.prototype.</span>exec
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.cursor.prototype.limit">
            function <span class="apidocSignatureSpan">nedb.cursor.prototype.</span>limit
            <span class="apidocSignatureSpan">(limit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.cursor.prototype.project">
            function <span class="apidocSignatureSpan">nedb.cursor.prototype.</span>project
            <span class="apidocSignatureSpan">(candidates)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.cursor.prototype.projection">
            function <span class="apidocSignatureSpan">nedb.cursor.prototype.</span>projection
            <span class="apidocSignatureSpan">(projection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.cursor.prototype.skip">
            function <span class="apidocSignatureSpan">nedb.cursor.prototype.</span>skip
            <span class="apidocSignatureSpan">(skip)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.cursor.prototype.sort">
            function <span class="apidocSignatureSpan">nedb.cursor.prototype.</span>sort
            <span class="apidocSignatureSpan">(sortQuery)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nedb.customUtils">module nedb.customUtils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.customUtils.uid">
            function <span class="apidocSignatureSpan">nedb.customUtils.</span>uid
            <span class="apidocSignatureSpan">(len)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nedb.datastore">module nedb.datastore</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.datastore.datastore">
            function <span class="apidocSignatureSpan">nedb.</span>datastore
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.datastore.super_">
            function <span class="apidocSignatureSpan">nedb.datastore.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nedb.datastore.prototype">module nedb.datastore.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.datastore.prototype._insert">
            function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>_insert
            <span class="apidocSignatureSpan">(newDoc, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.datastore.prototype._insertInCache">
            function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>_insertInCache
            <span class="apidocSignatureSpan">(preparedDoc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.datastore.prototype._insertMultipleDocsInCache">
            function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>_insertMultipleDocsInCache
            <span class="apidocSignatureSpan">(preparedDocs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.datastore.prototype._remove">
            function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>_remove
            <span class="apidocSignatureSpan">(query, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.datastore.prototype._update">
            function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>_update
            <span class="apidocSignatureSpan">(query, updateQuery, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.datastore.prototype.addToIndexes">
            function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>addToIndexes
            <span class="apidocSignatureSpan">(doc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.datastore.prototype.count">
            function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>count
            <span class="apidocSignatureSpan">(query, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.datastore.prototype.createNewId">
            function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>createNewId
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.datastore.prototype.ensureIndex">
            function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>ensureIndex
            <span class="apidocSignatureSpan">(options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.datastore.prototype.find">
            function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>find
            <span class="apidocSignatureSpan">(query, projection, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.datastore.prototype.findOne">
            function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>findOne
            <span class="apidocSignatureSpan">(query, projection, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.datastore.prototype.getAllData">
            function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>getAllData
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.datastore.prototype.getCandidates">
            function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>getCandidates
            <span class="apidocSignatureSpan">(query, dontExpireStaleDocs, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.datastore.prototype.insert">
            function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>insert
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.datastore.prototype.loadDatabase">
            function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>loadDatabase
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.datastore.prototype.prepareDocumentForInsertion">
            function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>prepareDocumentForInsertion
            <span class="apidocSignatureSpan">(newDoc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.datastore.prototype.remove">
            function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>remove
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.datastore.prototype.removeFromIndexes">
            function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>removeFromIndexes
            <span class="apidocSignatureSpan">(doc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.datastore.prototype.removeIndex">
            function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>removeIndex
            <span class="apidocSignatureSpan">(fieldName, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.datastore.prototype.resetIndexes">
            function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>resetIndexes
            <span class="apidocSignatureSpan">(newData)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.datastore.prototype.update">
            function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>update
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.datastore.prototype.updateIndexes">
            function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>updateIndexes
            <span class="apidocSignatureSpan">(oldDoc, newDoc)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nedb.executor">module nedb.executor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.executor.executor">
            function <span class="apidocSignatureSpan">nedb.</span>executor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nedb.executor.prototype">module nedb.executor.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.executor.prototype.processBuffer">
            function <span class="apidocSignatureSpan">nedb.executor.prototype.</span>processBuffer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.executor.prototype.push">
            function <span class="apidocSignatureSpan">nedb.executor.prototype.</span>push
            <span class="apidocSignatureSpan">(task, forceQueuing)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nedb.model">module nedb.model</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.model.areThingsEqual">
            function <span class="apidocSignatureSpan">nedb.model.</span>areThingsEqual
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.model.checkObject">
            function <span class="apidocSignatureSpan">nedb.model.</span>checkObject
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.model.compareThings">
            function <span class="apidocSignatureSpan">nedb.model.</span>compareThings
            <span class="apidocSignatureSpan">(a, b, _compareStrings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.model.deepCopy">
            function <span class="apidocSignatureSpan">nedb.model.</span>deepCopy
            <span class="apidocSignatureSpan">(obj, strictKeys)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.model.deserialize">
            function <span class="apidocSignatureSpan">nedb.model.</span>deserialize
            <span class="apidocSignatureSpan">(rawData)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.model.getDotValue">
            function <span class="apidocSignatureSpan">nedb.model.</span>getDotValue
            <span class="apidocSignatureSpan">(obj, field)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.model.isPrimitiveType">
            function <span class="apidocSignatureSpan">nedb.model.</span>isPrimitiveType
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.model.match">
            function <span class="apidocSignatureSpan">nedb.model.</span>match
            <span class="apidocSignatureSpan">(obj, query)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.model.modify">
            function <span class="apidocSignatureSpan">nedb.model.</span>modify
            <span class="apidocSignatureSpan">(obj, updateQuery)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.model.serialize">
            function <span class="apidocSignatureSpan">nedb.model.</span>serialize
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nedb.persistence">module nedb.persistence</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.persistence.persistence">
            function <span class="apidocSignatureSpan">nedb.</span>persistence
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.persistence.ensureDirectoryExists">
            function <span class="apidocSignatureSpan">nedb.persistence.</span>ensureDirectoryExists
            <span class="apidocSignatureSpan">(dir, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.persistence.getNWAppFilename">
            function <span class="apidocSignatureSpan">nedb.persistence.</span>getNWAppFilename
            <span class="apidocSignatureSpan">(appName, relativeFilename)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nedb.persistence.prototype">module nedb.persistence.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.persistence.prototype.compactDatafile">
            function <span class="apidocSignatureSpan">nedb.persistence.prototype.</span>compactDatafile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.persistence.prototype.loadDatabase">
            function <span class="apidocSignatureSpan">nedb.persistence.prototype.</span>loadDatabase
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.persistence.prototype.persistCachedDatabase">
            function <span class="apidocSignatureSpan">nedb.persistence.prototype.</span>persistCachedDatabase
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.persistence.prototype.persistNewState">
            function <span class="apidocSignatureSpan">nedb.persistence.prototype.</span>persistNewState
            <span class="apidocSignatureSpan">(newDocs, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.persistence.prototype.setAutocompactionInterval">
            function <span class="apidocSignatureSpan">nedb.persistence.prototype.</span>setAutocompactionInterval
            <span class="apidocSignatureSpan">(interval)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.persistence.prototype.stopAutocompaction">
            function <span class="apidocSignatureSpan">nedb.persistence.prototype.</span>stopAutocompaction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.persistence.prototype.treatRawData">
            function <span class="apidocSignatureSpan">nedb.persistence.prototype.</span>treatRawData
            <span class="apidocSignatureSpan">(rawData)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nedb.storage">module nedb.storage</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.storage.appendFile">
            function <span class="apidocSignatureSpan">nedb.storage.</span>appendFile
            <span class="apidocSignatureSpan">(path, data, options, callback_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.storage.crashSafeWriteFile">
            function <span class="apidocSignatureSpan">nedb.storage.</span>crashSafeWriteFile
            <span class="apidocSignatureSpan">(filename, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.storage.ensureDatafileIntegrity">
            function <span class="apidocSignatureSpan">nedb.storage.</span>ensureDatafileIntegrity
            <span class="apidocSignatureSpan">(filename, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.storage.ensureFileDoesntExist">
            function <span class="apidocSignatureSpan">nedb.storage.</span>ensureFileDoesntExist
            <span class="apidocSignatureSpan">(file, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.storage.exists">
            function <span class="apidocSignatureSpan">nedb.storage.</span>exists
            <span class="apidocSignatureSpan">(path, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.storage.flushToStorage">
            function <span class="apidocSignatureSpan">nedb.storage.</span>flushToStorage
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.storage.mkdirp">
            function <span class="apidocSignatureSpan">nedb.storage.</span>mkdirp
            <span class="apidocSignatureSpan">(p, opts, f, made)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.storage.readFile">
            function <span class="apidocSignatureSpan">nedb.storage.</span>readFile
            <span class="apidocSignatureSpan">(path, options, callback_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.storage.rename">
            function <span class="apidocSignatureSpan">nedb.storage.</span>rename
            <span class="apidocSignatureSpan">(oldPath, newPath, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.storage.unlink">
            function <span class="apidocSignatureSpan">nedb.storage.</span>unlink
            <span class="apidocSignatureSpan">(path, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.storage.writeFile">
            function <span class="apidocSignatureSpan">nedb.storage.</span>writeFile
            <span class="apidocSignatureSpan">(path, data, options, callback_)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nedb" id="apidoc.module.nedb">module nedb</a></h1>


    <h2>
        <a href="#apidoc.element.nedb.nedb" id="apidoc.element.nedb.nedb">
        function <span class="apidocSignatureSpan"></span>nedb
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Datastore(options) {
  var filename;

  // Retrocompatibility with v0.6 and before
  if (typeof options === &#x27;string&#x27;) {
    filename = options;
    this.inMemoryOnly = false;   // Default
  } else {
    options = options || {};
    filename = options.filename;
    this.inMemoryOnly = options.inMemoryOnly || false;
    this.autoload = options.autoload || false;
    this.timestampData = options.timestampData || false;
  }

  // Determine whether in memory or persistent
  if (!filename || typeof filename !== &#x27;string&#x27; || filename.length === 0) {
    this.filename = null;
    this.inMemoryOnly = true;
  } else {
    this.filename = filename;
  }

  // String comparison function
  this.compareStrings = options.compareStrings;

  // Persistence handling
  this.persistence = new Persistence({ db: this, nodeWebkitAppName: options.nodeWebkitAppName
                                      , afterSerialization: options.afterSerialization
                                      , beforeDeserialization: options.beforeDeserialization
                                      , corruptAlertThreshold: options.corruptAlertThreshold
                                      });

  // This new executor is ready if we don&#x27;t use persistence
  // If we do, it will only be ready once loadDatabase is called
  this.executor = new Executor();
  if (this.inMemoryOnly) { this.executor.ready = true; }

  // Indexed by field name, dot notation can be used
  // _id is always indexed and since _ids are generated randomly the underlying
  // binary is always well-balanced
  this.indexes = {};
  this.indexes._id = new Index({ fieldName: &#x27;_id&#x27;, unique: true });
  this.ttlIndexes = {};

  // Queue a load of the database right away and call the onload handler
  // By default (no onload handler), if there is an error there, no operation will be possible so warn the user by throwing an exception
  if (this.autoload) { this.loadDatabase(options.onload || function (err) {
    if (err) { throw err; }
  }); }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.cursor" id="apidoc.element.nedb.cursor">
        function <span class="apidocSignatureSpan">nedb.</span>cursor
        <span class="apidocSignatureSpan">(db, query, execFn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Cursor(db, query, execFn) {
  this.db = db;
  this.query = query || {};
  if (execFn) { this.execFn = execFn; }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.datastore" id="apidoc.element.nedb.datastore">
        function <span class="apidocSignatureSpan">nedb.</span>datastore
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Datastore(options) {
  var filename;

  // Retrocompatibility with v0.6 and before
  if (typeof options === &#x27;string&#x27;) {
    filename = options;
    this.inMemoryOnly = false;   // Default
  } else {
    options = options || {};
    filename = options.filename;
    this.inMemoryOnly = options.inMemoryOnly || false;
    this.autoload = options.autoload || false;
    this.timestampData = options.timestampData || false;
  }

  // Determine whether in memory or persistent
  if (!filename || typeof filename !== &#x27;string&#x27; || filename.length === 0) {
    this.filename = null;
    this.inMemoryOnly = true;
  } else {
    this.filename = filename;
  }

  // String comparison function
  this.compareStrings = options.compareStrings;

  // Persistence handling
  this.persistence = new Persistence({ db: this, nodeWebkitAppName: options.nodeWebkitAppName
                                      , afterSerialization: options.afterSerialization
                                      , beforeDeserialization: options.beforeDeserialization
                                      , corruptAlertThreshold: options.corruptAlertThreshold
                                      });

  // This new executor is ready if we don&#x27;t use persistence
  // If we do, it will only be ready once loadDatabase is called
  this.executor = new Executor();
  if (this.inMemoryOnly) { this.executor.ready = true; }

  // Indexed by field name, dot notation can be used
  // _id is always indexed and since _ids are generated randomly the underlying
  // binary is always well-balanced
  this.indexes = {};
  this.indexes._id = new Index({ fieldName: &#x27;_id&#x27;, unique: true });
  this.ttlIndexes = {};

  // Queue a load of the database right away and call the onload handler
  // By default (no onload handler), if there is an error there, no operation will be possible so warn the user by throwing an exception
  if (this.autoload) { this.loadDatabase(options.onload || function (err) {
    if (err) { throw err; }
  }); }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.executor" id="apidoc.element.nedb.executor">
        function <span class="apidocSignatureSpan">nedb.</span>executor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Executor() {
  this.buffer = [];
  this.ready = false;

  // This queue will execute all commands, one-by-one in order
  this.queue = async.queue(function (task, cb) {
    var newArguments = [];

    // task.arguments is an array-like object on which adding a new field doesn&#x27;t work, so we transform it into a real array
    for (var i = 0; i &#x3c; task.arguments.length; i += 1) { newArguments.push(task.arguments[i]); }
    var lastArg = task.arguments[task.arguments.length - 1];

    // Always tell the queue task is complete. Execute callback if any was given.
    if (typeof lastArg === &#x27;function&#x27;) {
      // Callback was supplied
      newArguments[newArguments.length - 1] = function () {
        if (typeof setImmediate === &#x27;function&#x27;) {
           setImmediate(cb);
        } else {
          process.nextTick(cb);
        }
        lastArg.apply(null, arguments);
      };
    } else if (!lastArg &#x26;&#x26; task.arguments.length !== 0) {
      // false/undefined/null supplied as callbback
      newArguments[newArguments.length - 1] = function () { cb(); };
    } else {
      // Nothing supplied as callback
      newArguments.push(function () { cb(); });
    }


    task.fn.apply(task.this, newArguments);
  }, 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.persistence" id="apidoc.element.nedb.persistence">
        function <span class="apidocSignatureSpan">nedb.</span>persistence
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Persistence(options) {
  var i, j, randomString;

  this.db = options.db;
  this.inMemoryOnly = this.db.inMemoryOnly;
  this.filename = this.db.filename;
  this.corruptAlertThreshold = options.corruptAlertThreshold !== undefined ? options.corruptAlertThreshold : 0.1;

  if (!this.inMemoryOnly &#x26;&#x26; this.filename &#x26;&#x26; this.filename.charAt(this.filename.length - 1) === &#x27;~&#x27;) {
    throw new Error(&#x22;The datafile name can&#x27;t end with a ~, which is reserved for crash safe backup files&#x22;);
  }

  // After serialization and before deserialization hooks with some basic sanity checks
  if (options.afterSerialization &#x26;&#x26; !options.beforeDeserialization) {
    throw new Error(&#x22;Serialization hook defined but deserialization hook undefined, cautiously refusing to start NeDB to prevent
 dataloss&#x22;);
  }
  if (!options.afterSerialization &#x26;&#x26; options.beforeDeserialization) {
    throw new Error(&#x22;Serialization hook undefined but deserialization hook defined, cautiously refusing to start NeDB to prevent
 dataloss&#x22;);
  }
  this.afterSerialization = options.afterSerialization || function (s) { return s; };
  this.beforeDeserialization = options.beforeDeserialization || function (s) { return s; };
  for (i = 1; i &#x3c; 30; i += 1) {
    for (j = 0; j &#x3c; 10; j += 1) {
      randomString = customUtils.uid(i);
      if (this.beforeDeserialization(this.afterSerialization(randomString)) !== randomString) {
        throw new Error(&#x22;beforeDeserialization is not the reverse of afterSerialization, cautiously refusing to start NeDB to prevent
 dataloss&#x22;);
      }
    }
  }

  // For NW apps, store data in the same directory where NW stores application data
  if (this.filename &#x26;&#x26; options.nodeWebkitAppName) {
    console.log(&#x22;==================================================================&#x22;);
    console.log(&#x22;WARNING: The nodeWebkitAppName option is deprecated&#x22;);
    console.log(&#x22;To get the path to the directory where Node Webkit stores the data&#x22;);
    console.log(&#x22;for your app, use the internal nw.gui module like this&#x22;);
    console.log(&#x22;require(&#x27;nw.gui&#x27;).App.dataPath&#x22;);
    console.log(&#x22;See https://github.com/rogerwang/node-webkit/issues/500&#x22;);
    console.log(&#x22;==================================================================&#x22;);
    this.filename = Persistence.getNWAppFilename(options.nodeWebkitAppName, this.filename);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.super_" id="apidoc.element.nedb.super_">
        function <span class="apidocSignatureSpan">nedb.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nedb.commonUtilities" id="apidoc.module.nedb.commonUtilities">module nedb.commonUtilities</a></h1>


    <h2>
        <a href="#apidoc.element.nedb.commonUtilities.findDocs" id="apidoc.element.nedb.commonUtilities.findDocs">
        function <span class="apidocSignatureSpan">nedb.commonUtilities.</span>findDocs
        <span class="apidocSignatureSpan">(d, n, profiler, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findDocs = function (d, n, profiler, cb) {
  var beg = new Date()
    , order = getRandomArray(n)
    ;

  profiler.step(&#x22;Finding &#x22; + n + &#x22; documents&#x22;);

  function runFrom(i) {
    if (i === n) {   // Finished
      console.log(&#x22;===== RESULT (find) ===== &#x22; + Math.floor(1000* n / profiler.elapsedSinceLastStep()) + &#x22; ops/s&#x22;);
      profiler.step(&#x27;Finished finding &#x27; + n + &#x27; docs&#x27;);
      return cb();
    }

    d.find({ docNumber: order[i] }, function (err, docs) {
      if (docs.length !== 1 || docs[0].docNumber !== order[i]) { return cb(&#x27;One find didnt work&#x27;); }
      executeAsap(function () {
        runFrom(i + 1);
      });
    });
  }
  runFrom(0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.commonUtilities.findDocsWithIn" id="apidoc.element.nedb.commonUtilities.findDocsWithIn">
        function <span class="apidocSignatureSpan">nedb.commonUtilities.</span>findDocsWithIn
        <span class="apidocSignatureSpan">(d, n, profiler, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findDocsWithIn = function (d, n, profiler, cb) {
  var beg = new Date()
    , order = getRandomArray(n)
    , ins = [], i, j
    , arraySize = Math.min(10, n)   // The array for $in needs to be smaller than n (inclusive)
    ;

  // Preparing all the $in arrays, will take some time
  for (i = 0; i &#x3c; n; i += 1) {
    ins[i] = [];

    for (j = 0; j &#x3c; arraySize; j += 1) {
      ins[i].push((i + j) % n);
    }
  }

  profiler.step(&#x22;Finding &#x22; + n + &#x22; documents WITH $IN OPERATOR&#x22;);

  function runFrom(i) {
    if (i === n) {   // Finished
      console.log(&#x22;===== RESULT (find with in selector) ===== &#x22; + Math.floor(1000* n / profiler.elapsedSinceLastStep()) + &#x22; ops/
s&#x22;);
      profiler.step(&#x27;Finished finding &#x27; + n + &#x27; docs&#x27;);
      return cb();
    }

    d.find({ docNumber: { $in: ins[i] } }, function (err, docs) {
      if (docs.length !== arraySize) { return cb(&#x27;One find didnt work&#x27;); }
      executeAsap(function () {
        runFrom(i + 1);
      });
    });
  }
  runFrom(0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.commonUtilities.findOneDocs" id="apidoc.element.nedb.commonUtilities.findOneDocs">
        function <span class="apidocSignatureSpan">nedb.commonUtilities.</span>findOneDocs
        <span class="apidocSignatureSpan">(d, n, profiler, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findOneDocs = function (d, n, profiler, cb) {
  var beg = new Date()
    , order = getRandomArray(n)
    ;

  profiler.step(&#x22;FindingOne &#x22; + n + &#x22; documents&#x22;);

  function runFrom(i) {
    if (i === n) {   // Finished
      console.log(&#x22;===== RESULT (findOne) ===== &#x22; + Math.floor(1000* n / profiler.elapsedSinceLastStep()) + &#x22; ops/s&#x22;);
      profiler.step(&#x27;Finished finding &#x27; + n + &#x27; docs&#x27;);
      return cb();
    }

    d.findOne({ docNumber: order[i] }, function (err, doc) {
      if (!doc || doc.docNumber !== order[i]) { return cb(&#x27;One find didnt work&#x27;); }
      executeAsap(function () {
        runFrom(i + 1);
      });
    });
  }
  runFrom(0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.commonUtilities.getConfiguration" id="apidoc.element.nedb.commonUtilities.getConfiguration">
        function <span class="apidocSignatureSpan">nedb.commonUtilities.</span>getConfiguration
        <span class="apidocSignatureSpan">(benchDb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getConfiguration = function (benchDb) {
  var d, n
    , program = require(&#x27;commander&#x27;)
    ;

  program
    .option(&#x27;-n --number [number]&#x27;, &#x27;Size of the collection to test on&#x27;, parseInt)
    .option(&#x27;-i --with-index&#x27;, &#x27;Use an index&#x27;)
    .option(&#x27;-m --in-memory&#x27;, &#x27;Test with an in-memory only store&#x27;)
    .parse(process.argv);

  n = program.number || 10000;

  console.log(&#x22;----------------------------&#x22;);
  console.log(&#x22;Test with &#x22; + n + &#x22; documents&#x22;);
  console.log(program.withIndex ? &#x22;Use an index&#x22; : &#x22;Don&#x27;t use an index&#x22;);
  console.log(program.inMemory ? &#x22;Use an in-memory datastore&#x22; : &#x22;Use a persistent datastore&#x22;);
  console.log(&#x22;----------------------------&#x22;);

  d = new Datastore({ filename: benchDb
                    , inMemoryOnly: program.inMemory
                    });

  return { n: n, d: d, program: program };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  , benchDb = &#x27;workspace/find.bench.db&#x27;
  , fs = require(&#x27;fs&#x27;)
  , path = require(&#x27;path&#x27;)
  , async = require(&#x27;async&#x27;)
  , execTime = require(&#x27;exec-time&#x27;)
  , profiler = new execTime(&#x27;FIND BENCH&#x27;)
  , commonUtilities = require(&#x27;./commonUtilities&#x27;)
  , config = commonUtilities.<span class="apidocCodeKeywordSpan">getConfiguration</span>(benchDb)
  , d = config.d
  , n = config.n
  ;

async.waterfall([
  async.apply(commonUtilities.prepareDb, benchDb)
, function (cb) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.commonUtilities.getRandomArray" id="apidoc.element.nedb.commonUtilities.getRandomArray">
        function <span class="apidocSignatureSpan">nedb.commonUtilities.</span>getRandomArray
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getRandomArray(n) {
  var res = []
    , i, j, temp
    ;

  for (i = 0; i &#x3c; n; i += 1) { res[i] = i; }

  for (i = n - 1; i &#x3e;= 1; i -= 1) {
    j = Math.floor((i + 1) * Math.random());
    temp = res[i];
    res[i] = res[j];
    res[j] = temp;
  }

  return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.commonUtilities.insertDocs" id="apidoc.element.nedb.commonUtilities.insertDocs">
        function <span class="apidocSignatureSpan">nedb.commonUtilities.</span>insertDocs
        <span class="apidocSignatureSpan">(d, n, profiler, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insertDocs = function (d, n, profiler, cb) {
  var beg = new Date()
    , order = getRandomArray(n)
    ;

  profiler.step(&#x27;Begin inserting &#x27; + n + &#x27; docs&#x27;);

  function runFrom(i) {
    if (i === n) {   // Finished
      var opsPerSecond = Math.floor(1000* n / profiler.elapsedSinceLastStep());
      console.log(&#x22;===== RESULT (insert) ===== &#x22; + opsPerSecond + &#x22; ops/s&#x22;);
      profiler.step(&#x27;Finished inserting &#x27; + n + &#x27; docs&#x27;);
      profiler.insertOpsPerSecond = opsPerSecond;
      return cb();
    }

    d.insert({ docNumber: order[i] }, function (err) {
      executeAsap(function () {
        runFrom(i + 1);
      });
    });
  }
  runFrom(0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.commonUtilities.loadDatabase" id="apidoc.element.nedb.commonUtilities.loadDatabase">
        function <span class="apidocSignatureSpan">nedb.commonUtilities.</span>loadDatabase
        <span class="apidocSignatureSpan">(d, n, profiler, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadDatabase = function (d, n, profiler, cb) {
  var beg = new Date()
    , order = getRandomArray(n)
    ;

  profiler.step(&#x22;Loading the database &#x22; + n + &#x22; times&#x22;);

  function runFrom(i) {
    if (i === n) {   // Finished
      console.log(&#x22;===== RESULT ===== &#x22; + Math.floor(1000* n / profiler.elapsedSinceLastStep()) + &#x22; ops/s&#x22;);
      profiler.step(&#x27;Finished loading a database&#x27; + n + &#x27; times&#x27;);
      return cb();
    }

    d.loadDatabase(function (err) {
      executeAsap(function () {
        runFrom(i + 1);
      });
    });
  }
  runFrom(0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var Datastore = require(&#x27;nedb&#x27;)
, db = new Datastore();


// Type 2: Persistent datastore with manual loading
var Datastore = require(&#x27;nedb&#x27;)
, db = new Datastore({ filename: &#x27;path/to/datafile&#x27; });
db.<span class="apidocCodeKeywordSpan">loadDatabase</span>(function (err) {    // Callback is optional
// Now commands will be executed
});


// Type 3: Persistent datastore with automatic loading
var Datastore = require(&#x27;nedb&#x27;)
, db = new Datastore({ filename: &#x27;path/to/datafile&#x27;, autoload: true });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.commonUtilities.prepareDb" id="apidoc.element.nedb.commonUtilities.prepareDb">
        function <span class="apidocSignatureSpan">nedb.commonUtilities.</span>prepareDb
        <span class="apidocSignatureSpan">(filename, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prepareDb = function (filename, cb) {
  Persistence.ensureDirectoryExists(path.dirname(filename), function () {
    fs.exists(filename, function (exists) {
      if (exists) {
        fs.unlink(filename, cb);
      } else { return cb(); }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.commonUtilities.removeDocs" id="apidoc.element.nedb.commonUtilities.removeDocs">
        function <span class="apidocSignatureSpan">nedb.commonUtilities.</span>removeDocs
        <span class="apidocSignatureSpan">(options, d, n, profiler, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeDocs = function (options, d, n, profiler, cb) {
  var beg = new Date()
    , order = getRandomArray(n)
    ;

  profiler.step(&#x22;Removing &#x22; + n + &#x22; documents&#x22;);

  function runFrom(i) {
    if (i === n) {   // Finished
      // opsPerSecond corresponds to 1 insert + 1 remove, needed to keep collection size at 10,000
      // We need to subtract the time taken by one insert to get the time actually taken by one remove
      var opsPerSecond = Math.floor(1000 * n / profiler.elapsedSinceLastStep());
      var removeOpsPerSecond = Math.floor(1 / ((1 / opsPerSecond) - (1 / profiler.insertOpsPerSecond)))
      console.log(&#x22;===== RESULT (remove) ===== &#x22; + removeOpsPerSecond + &#x22; ops/s&#x22;);
      profiler.step(&#x27;Finished removing &#x27; + n + &#x27; docs&#x27;);
      return cb();
    }

    d.remove({ docNumber: order[i] }, options, function (err, nr) {
      if (err) { return cb(err); }
      if (nr !== 1) { return cb(&#x27;One remove didnt work&#x27;); }
      d.insert({ docNumber: order[i] }, function (err) {   // We need to reinsert the doc so that we keep the collection&#x27;s size
at n
                                                           // So actually we&#x27;re calculating the average time taken by one insert
 + one remove
        executeAsap(function () {
          runFrom(i + 1);
        });
      });
    });
  }
  runFrom(0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.commonUtilities.updateDocs" id="apidoc.element.nedb.commonUtilities.updateDocs">
        function <span class="apidocSignatureSpan">nedb.commonUtilities.</span>updateDocs
        <span class="apidocSignatureSpan">(options, d, n, profiler, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateDocs = function (options, d, n, profiler, cb) {
  var beg = new Date()
    , order = getRandomArray(n)
    ;

  profiler.step(&#x22;Updating &#x22; + n + &#x22; documents&#x22;);

  function runFrom(i) {
    if (i === n) {   // Finished
      console.log(&#x22;===== RESULT (update) ===== &#x22; + Math.floor(1000* n / profiler.elapsedSinceLastStep()) + &#x22; ops/s&#x22;);
      profiler.step(&#x27;Finished updating &#x27; + n + &#x27; docs&#x27;);
      return cb();
    }

    // Will not actually modify the document but will take the same time
    d.update({ docNumber: order[i] }, { docNumber: order[i] }, options, function (err, nr) {
      if (err) { return cb(err); }
      if (nr !== 1) { return cb(&#x27;One update didnt work&#x27;); }
      executeAsap(function () {
        runFrom(i + 1);
      });
    });
  }
  runFrom(0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nedb.cursor" id="apidoc.module.nedb.cursor">module nedb.cursor</a></h1>


    <h2>
        <a href="#apidoc.element.nedb.cursor.cursor" id="apidoc.element.nedb.cursor.cursor">
        function <span class="apidocSignatureSpan">nedb.</span>cursor
        <span class="apidocSignatureSpan">(db, query, execFn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Cursor(db, query, execFn) {
  this.db = db;
  this.query = query || {};
  if (execFn) { this.execFn = execFn; }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nedb.cursor.prototype" id="apidoc.module.nedb.cursor.prototype">module nedb.cursor.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.nedb.cursor.prototype._exec" id="apidoc.element.nedb.cursor.prototype._exec">
        function <span class="apidocSignatureSpan">nedb.cursor.prototype.</span>_exec
        <span class="apidocSignatureSpan">(_callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_exec = function (_callback) {
  var res = [], added = 0, skipped = 0, self = this
    , error = null
    , i, keys, key
    ;

  function callback (error, res) {
    if (self.execFn) {
      return self.execFn(error, res, _callback);
    } else {
      return _callback(error, res);
    }
  }

  this.db.getCandidates(this.query, function (err, candidates) {
    if (err) { return callback(err); }

    try {
      for (i = 0; i &#x3c; candidates.length; i += 1) {
        if (model.match(candidates[i], self.query)) {
          // If a sort is defined, wait for the results to be sorted before applying limit and skip
          if (!self._sort) {
            if (self._skip &#x26;&#x26; self._skip &#x3e; skipped) {
              skipped += 1;
            } else {
              res.push(candidates[i]);
              added += 1;
              if (self._limit &#x26;&#x26; self._limit &#x3c;= added) { break; }
            }
          } else {
            res.push(candidates[i]);
          }
        }
      }
    } catch (err) {
      return callback(err);
    }

    // Apply all sorts
    if (self._sort) {
      keys = Object.keys(self._sort);

      // Sorting
      var criteria = [];
      for (i = 0; i &#x3c; keys.length; i++) {
        key = keys[i];
        criteria.push({ key: key, direction: self._sort[key] });
      }
      res.sort(function(a, b) {
        var criterion, compare, i;
        for (i = 0; i &#x3c; criteria.length; i++) {
          criterion = criteria[i];
          compare = criterion.direction * model.compareThings(model.getDotValue(a, criterion.key), model.getDotValue(b, criterion
.key), self.db.compareStrings);
          if (compare !== 0) {
            return compare;
          }
        }
        return 0;
      });

      // Applying limit and skip
      var limit = self._limit || res.length
        , skip = self._skip || 0;

      res = res.slice(skip, skip + limit);
    }

    // Apply projection
    try {
      res = self.project(res);
    } catch (e) {
      error = e;
      res = undefined;
    }

    return callback(error, res);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  async.waterfall([
  function (cb) {   // If upsert option is set, check whether we need to insert the doc
    if (!upsert) { return cb(); }

    // Need to use an internal function not tied to the executor to avoid deadlock
    var cursor = new Cursor(self, query);
    cursor.limit(1).<span class="apidocCodeKeywordSpan">_exec</span>(function (err, docs) {
      if (err) { return callback(err); }
      if (docs.length === 1) {
return cb();
      } else {
var toBeInserted;

try {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.cursor.prototype.exec" id="apidoc.element.nedb.cursor.prototype.exec">
        function <span class="apidocSignatureSpan">nedb.cursor.prototype.</span>exec
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exec = function () {
  this.db.executor.push({ this: this, fn: this._exec, arguments: arguments });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Let&#x27;s say the database contains these 4 documents
// doc1 = { _id: &#x27;id1&#x27;, planet: &#x27;Mars&#x27;, system: &#x27;solar&#x27;, inhabited: false, satellites: [&#x27;Phobos
&#x27;, &#x27;Deimos&#x27;] }
// doc2 = { _id: &#x27;id2&#x27;, planet: &#x27;Earth&#x27;, system: &#x27;solar&#x27;, inhabited: true, humans: { genders: 2, eyes
: true } }
// doc3 = { _id: &#x27;id3&#x27;, planet: &#x27;Jupiter&#x27;, system: &#x27;solar&#x27;, inhabited: false }
// doc4 = { _id: &#x27;id4&#x27;, planet: &#x27;Omicron Persei 8&#x27;, system: &#x27;futurama&#x27;, inhabited: true, humans: {
genders: 7 } }

// No query used means all results are returned (before the Cursor modifiers)
db.find({}).sort({ planet: 1 }).skip(1).limit(2).<span class="apidocCodeKeywordSpan">exec</span>(function (err, docs) {
  // docs is [doc3, doc1]
});

// You can sort in reverse order like this
db.find({ system: &#x27;solar&#x27; }).sort({ planet: -1 }).exec(function (err, docs) {
  // docs is [doc1, doc3, doc2]
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.cursor.prototype.limit" id="apidoc.element.nedb.cursor.prototype.limit">
        function <span class="apidocSignatureSpan">nedb.cursor.prototype.</span>limit
        <span class="apidocSignatureSpan">(limit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">limit = function (limit) {
  this._limit = limit;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Let&#x27;s say the database contains these 4 documents
// doc1 = { _id: &#x27;id1&#x27;, planet: &#x27;Mars&#x27;, system: &#x27;solar&#x27;, inhabited: false, satellites: [&#x27;Phobos
&#x27;, &#x27;Deimos&#x27;] }
// doc2 = { _id: &#x27;id2&#x27;, planet: &#x27;Earth&#x27;, system: &#x27;solar&#x27;, inhabited: true, humans: { genders: 2, eyes
: true } }
// doc3 = { _id: &#x27;id3&#x27;, planet: &#x27;Jupiter&#x27;, system: &#x27;solar&#x27;, inhabited: false }
// doc4 = { _id: &#x27;id4&#x27;, planet: &#x27;Omicron Persei 8&#x27;, system: &#x27;futurama&#x27;, inhabited: true, humans: {
genders: 7 } }

// No query used means all results are returned (before the Cursor modifiers)
db.find({}).sort({ planet: 1 }).skip(1).<span class="apidocCodeKeywordSpan">limit</span>(2).exec(function (err, docs) {
  // docs is [doc3, doc1]
});

// You can sort in reverse order like this
db.find({ system: &#x27;solar&#x27; }).sort({ planet: -1 }).exec(function (err, docs) {
  // docs is [doc1, doc3, doc2]
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.cursor.prototype.project" id="apidoc.element.nedb.cursor.prototype.project">
        function <span class="apidocSignatureSpan">nedb.cursor.prototype.</span>project
        <span class="apidocSignatureSpan">(candidates)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">project = function (candidates) {
  var res = [], self = this
    , keepId, action, keys
    ;

  if (this._projection === undefined || Object.keys(this._projection).length === 0) {
    return candidates;
  }

  keepId = this._projection._id === 0 ? false : true;
  this._projection = _.omit(this._projection, &#x27;_id&#x27;);

  // Check for consistency
  keys = Object.keys(this._projection);
  keys.forEach(function (k) {
    if (action !== undefined &#x26;&#x26; self._projection[k] !== action) { throw new Error(&#x22;Can&#x27;t both keep and omit fields except for _id
&#x22;); }
    action = self._projection[k];
  });

  // Do the actual projection
  candidates.forEach(function (candidate) {
    var toPush;
    if (action === 1) {   // pick-type projection
      toPush = { $set: {} };
      keys.forEach(function (k) {
        toPush.$set[k] = model.getDotValue(candidate, k);
        if (toPush.$set[k] === undefined) { delete toPush.$set[k]; }
      });
      toPush = model.modify({}, toPush);
    } else {   // omit-type projection
      toPush = { $unset: {} };
      keys.forEach(function (k) { toPush.$unset[k] = true });
      toPush = model.modify(candidate, toPush);
    }
    if (keepId) {
      toPush._id = candidate._id;
    } else {
      delete toPush._id;
    }
    res.push(toPush);
  });

  return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      , skip = self._skip || 0;

    res = res.slice(skip, skip + limit);
  }

  // Apply projection
  try {
    res = self.<span class="apidocCodeKeywordSpan">project</span>(res);
  } catch (e) {
    error = e;
    res = undefined;
  }

  return callback(error, res);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.cursor.prototype.projection" id="apidoc.element.nedb.cursor.prototype.projection">
        function <span class="apidocSignatureSpan">nedb.cursor.prototype.</span>projection
        <span class="apidocSignatureSpan">(projection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">projection = function (projection) {
  this._projection = projection;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Failure: using both modes at the same time
db.find({ planet: &#x27;Mars&#x27; }, { planet: 0, system: 1 }, function (err, docs) {
  // err is the error message, docs is undefined
});

// You can also use it in a Cursor way but this syntax is not compatible with MongoDB
db.find({ planet: &#x27;Mars&#x27; }).<span class="apidocCodeKeywordSpan">projection</span>({ planet: 1, system: 1 }).exec(function
 (err, docs) {
  // docs is [{ planet: &#x27;Mars&#x27;, system: &#x27;solar&#x27;, _id: &#x27;id1&#x27; }]
});

// Project on a nested document
db.findOne({ planet: &#x27;Earth&#x27; }).projection({ planet: 1, &#x27;humans.genders&#x27;: 1 }).exec(function (err, doc) {
  // doc is { planet: &#x27;Earth&#x27;, _id: &#x27;id2&#x27;, humans: { genders: 2 } }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.cursor.prototype.skip" id="apidoc.element.nedb.cursor.prototype.skip">
        function <span class="apidocSignatureSpan">nedb.cursor.prototype.</span>skip
        <span class="apidocSignatureSpan">(skip)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skip = function (skip) {
  this._skip = skip;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Let&#x27;s say the database contains these 4 documents
// doc1 = { _id: &#x27;id1&#x27;, planet: &#x27;Mars&#x27;, system: &#x27;solar&#x27;, inhabited: false, satellites: [&#x27;Phobos
&#x27;, &#x27;Deimos&#x27;] }
// doc2 = { _id: &#x27;id2&#x27;, planet: &#x27;Earth&#x27;, system: &#x27;solar&#x27;, inhabited: true, humans: { genders: 2, eyes
: true } }
// doc3 = { _id: &#x27;id3&#x27;, planet: &#x27;Jupiter&#x27;, system: &#x27;solar&#x27;, inhabited: false }
// doc4 = { _id: &#x27;id4&#x27;, planet: &#x27;Omicron Persei 8&#x27;, system: &#x27;futurama&#x27;, inhabited: true, humans: {
genders: 7 } }

// No query used means all results are returned (before the Cursor modifiers)
db.find({}).sort({ planet: 1 }).<span class="apidocCodeKeywordSpan">skip</span>(1).limit(2).exec(function (err, docs) {
  // docs is [doc3, doc1]
});

// You can sort in reverse order like this
db.find({ system: &#x27;solar&#x27; }).sort({ planet: -1 }).exec(function (err, docs) {
  // docs is [doc1, doc3, doc2]
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.cursor.prototype.sort" id="apidoc.element.nedb.cursor.prototype.sort">
        function <span class="apidocSignatureSpan">nedb.cursor.prototype.</span>sort
        <span class="apidocSignatureSpan">(sortQuery)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sort = function (sortQuery) {
  this._sort = sortQuery;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Let&#x27;s say the database contains these 4 documents
// doc1 = { _id: &#x27;id1&#x27;, planet: &#x27;Mars&#x27;, system: &#x27;solar&#x27;, inhabited: false, satellites: [&#x27;Phobos
&#x27;, &#x27;Deimos&#x27;] }
// doc2 = { _id: &#x27;id2&#x27;, planet: &#x27;Earth&#x27;, system: &#x27;solar&#x27;, inhabited: true, humans: { genders: 2, eyes
: true } }
// doc3 = { _id: &#x27;id3&#x27;, planet: &#x27;Jupiter&#x27;, system: &#x27;solar&#x27;, inhabited: false }
// doc4 = { _id: &#x27;id4&#x27;, planet: &#x27;Omicron Persei 8&#x27;, system: &#x27;futurama&#x27;, inhabited: true, humans: {
genders: 7 } }

// No query used means all results are returned (before the Cursor modifiers)
db.find({}).<span class="apidocCodeKeywordSpan">sort</span>({ planet: 1 }).skip(1).limit(2).exec(function (err, docs) {
  // docs is [doc3, doc1]
});

// You can sort in reverse order like this
db.find({ system: &#x27;solar&#x27; }).sort({ planet: -1 }).exec(function (err, docs) {
  // docs is [doc1, doc3, doc2]
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nedb.customUtils" id="apidoc.module.nedb.customUtils">module nedb.customUtils</a></h1>


    <h2>
        <a href="#apidoc.element.nedb.customUtils.uid" id="apidoc.element.nedb.customUtils.uid">
        function <span class="apidocSignatureSpan">nedb.customUtils.</span>uid
        <span class="apidocSignatureSpan">(len)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function uid(len) {
  return crypto.randomBytes(Math.ceil(Math.max(8, len * 2)))
    .toString(&#x27;base64&#x27;)
    .replace(/[+\/]/g, &#x27;&#x27;)
    .slice(0, len);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  });
};

/**
 * Create a new _id that&#x27;s not already in use
 */
Datastore.prototype.createNewId = function () {
  var tentativeId = customUtils.<span class="apidocCodeKeywordSpan">uid</span>(16);
  // Try as many times as needed to get an unused _id. As explained in customUtils, the probability of this ever happening is extremely
 small, so this is O(1)
  if (this.indexes._id.getMatching(tentativeId).length &#x3e; 0) {
    tentativeId = this.createNewId();
  }
  return tentativeId;
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nedb.datastore" id="apidoc.module.nedb.datastore">module nedb.datastore</a></h1>


    <h2>
        <a href="#apidoc.element.nedb.datastore.datastore" id="apidoc.element.nedb.datastore.datastore">
        function <span class="apidocSignatureSpan">nedb.</span>datastore
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Datastore(options) {
  var filename;

  // Retrocompatibility with v0.6 and before
  if (typeof options === &#x27;string&#x27;) {
    filename = options;
    this.inMemoryOnly = false;   // Default
  } else {
    options = options || {};
    filename = options.filename;
    this.inMemoryOnly = options.inMemoryOnly || false;
    this.autoload = options.autoload || false;
    this.timestampData = options.timestampData || false;
  }

  // Determine whether in memory or persistent
  if (!filename || typeof filename !== &#x27;string&#x27; || filename.length === 0) {
    this.filename = null;
    this.inMemoryOnly = true;
  } else {
    this.filename = filename;
  }

  // String comparison function
  this.compareStrings = options.compareStrings;

  // Persistence handling
  this.persistence = new Persistence({ db: this, nodeWebkitAppName: options.nodeWebkitAppName
                                      , afterSerialization: options.afterSerialization
                                      , beforeDeserialization: options.beforeDeserialization
                                      , corruptAlertThreshold: options.corruptAlertThreshold
                                      });

  // This new executor is ready if we don&#x27;t use persistence
  // If we do, it will only be ready once loadDatabase is called
  this.executor = new Executor();
  if (this.inMemoryOnly) { this.executor.ready = true; }

  // Indexed by field name, dot notation can be used
  // _id is always indexed and since _ids are generated randomly the underlying
  // binary is always well-balanced
  this.indexes = {};
  this.indexes._id = new Index({ fieldName: &#x27;_id&#x27;, unique: true });
  this.ttlIndexes = {};

  // Queue a load of the database right away and call the onload handler
  // By default (no onload handler), if there is an error there, no operation will be possible so warn the user by throwing an exception
  if (this.autoload) { this.loadDatabase(options.onload || function (err) {
    if (err) { throw err; }
  }); }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.datastore.super_" id="apidoc.element.nedb.datastore.super_">
        function <span class="apidocSignatureSpan">nedb.datastore.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nedb.datastore.prototype" id="apidoc.module.nedb.datastore.prototype">module nedb.datastore.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.nedb.datastore.prototype._insert" id="apidoc.element.nedb.datastore.prototype._insert">
        function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>_insert
        <span class="apidocSignatureSpan">(newDoc, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_insert = function (newDoc, cb) {
  var callback = cb || function () {}
    , preparedDoc
    ;

  try {
    preparedDoc = this.prepareDocumentForInsertion(newDoc)
    this._insertInCache(preparedDoc);
  } catch (e) {
    return callback(e);
  }

  this.persistence.persistNewState(util.isArray(preparedDoc) ? preparedDoc : [preparedDoc], function (err) {
    if (err) { return callback(err); }
    return callback(null, model.deepCopy(preparedDoc));
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        try {
          toBeInserted = model.modify(model.deepCopy(query, true), updateQuery);
        } catch (err) {
          return callback(err);
        }
      }

      return self.<span class="apidocCodeKeywordSpan">_insert</span>(toBeInserted, function (err, newDoc) {
        if (err) { return callback(err); }
        return callback(null, 1, newDoc, true);
      });
    }
  });
}
, function () {   // Perform the update
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.datastore.prototype._insertInCache" id="apidoc.element.nedb.datastore.prototype._insertInCache">
        function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>_insertInCache
        <span class="apidocSignatureSpan">(preparedDoc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_insertInCache = function (preparedDoc) {
  if (util.isArray(preparedDoc)) {
    this._insertMultipleDocsInCache(preparedDoc);
  } else {
    this.addToIndexes(preparedDoc);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Datastore.prototype._insert = function (newDoc, cb) {
var callback = cb || function () {}
  , preparedDoc
  ;

try {
  preparedDoc = this.prepareDocumentForInsertion(newDoc)
  this.<span class="apidocCodeKeywordSpan">_insertInCache</span>(preparedDoc);
} catch (e) {
  return callback(e);
}

this.persistence.persistNewState(util.isArray(preparedDoc) ? preparedDoc : [preparedDoc], function (err) {
  if (err) { return callback(err); }
  return callback(null, model.deepCopy(preparedDoc));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.datastore.prototype._insertMultipleDocsInCache" id="apidoc.element.nedb.datastore.prototype._insertMultipleDocsInCache">
        function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>_insertMultipleDocsInCache
        <span class="apidocSignatureSpan">(preparedDocs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_insertMultipleDocsInCache = function (preparedDocs) {
  var i, failingI, error;

  for (i = 0; i &#x3c; preparedDocs.length; i += 1) {
    try {
      this.addToIndexes(preparedDocs[i]);
    } catch (e) {
      error = e;
      failingI = i;
      break;
    }
  }

  if (error) {
    for (i = 0; i &#x3c; failingI; i += 1) {
      this.removeFromIndexes(preparedDocs[i]);
    }

    throw error;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* If newDoc is an array of documents, this will insert all documents in the cache
* @api private
*/
Datastore.prototype._insertInCache = function (preparedDoc) {
 if (util.isArray(preparedDoc)) {
   this.<span class="apidocCodeKeywordSpan">_insertMultipleDocsInCache</span>(preparedDoc);
 } else {
   this.addToIndexes(preparedDoc);
 }
};

/**
* If one insertion fails (e.g. because of a unique constraint), roll back all previous
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.datastore.prototype._remove" id="apidoc.element.nedb.datastore.prototype._remove">
        function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>_remove
        <span class="apidocSignatureSpan">(query, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_remove = function (query, options, cb) {
  var callback
    , self = this, numRemoved = 0, removedDocs = [], multi
    ;

  if (typeof options === &#x27;function&#x27;) { cb = options; options = {}; }
  callback = cb || function () {};
  multi = options.multi !== undefined ? options.multi : false;

  this.getCandidates(query, true, function (err, candidates) {
    if (err) { return callback(err); }

    try {
      candidates.forEach(function (d) {
        if (model.match(d, query) &#x26;&#x26; (multi || numRemoved === 0)) {
          numRemoved += 1;
          removedDocs.push({ $$deleted: true, _id: d._id });
          self.removeFromIndexes(d);
        }
      });
    } catch (err) { return callback(err); }

    self.persistence.persistNewState(removedDocs, function (err) {
      if (err) { return callback(err); }
      return callback(null, numRemoved);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        valid = false;
      }
    });
    if (valid) { validDocs.push(doc); } else { expiredDocsIds.push(doc._id); }
  });

  async.eachSeries(expiredDocsIds, function (_id, cb) {
    self.<span class="apidocCodeKeywordSpan">_remove</span>({ _id: _id }, {}, function (err) {
      if (err) { return callback(err); }
      return cb();
    });
  }, function (err) {
    return callback(null, validDocs);
  });
}]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.datastore.prototype._update" id="apidoc.element.nedb.datastore.prototype._update">
        function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>_update
        <span class="apidocSignatureSpan">(query, updateQuery, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_update = function (query, updateQuery, options, cb) {
  var callback
    , self = this
    , numReplaced = 0
    , multi, upsert
    , i
    ;

  if (typeof options === &#x27;function&#x27;) { cb = options; options = {}; }
  callback = cb || function () {};
  multi = options.multi !== undefined ? options.multi : false;
  upsert = options.upsert !== undefined ? options.upsert : false;

  async.waterfall([
  function (cb) {   // If upsert option is set, check whether we need to insert the doc
    if (!upsert) { return cb(); }

    // Need to use an internal function not tied to the executor to avoid deadlock
    var cursor = new Cursor(self, query);
    cursor.limit(1)._exec(function (err, docs) {
      if (err) { return callback(err); }
      if (docs.length === 1) {
        return cb();
      } else {
        var toBeInserted;

        try {
          model.checkObject(updateQuery);
          // updateQuery is a simple object with no modifier, use it as the document to insert
          toBeInserted = updateQuery;
        } catch (e) {
          // updateQuery contains modifiers, use the find query as the base,
          // strip it from all operators and update it according to updateQuery
          try {
            toBeInserted = model.modify(model.deepCopy(query, true), updateQuery);
          } catch (err) {
            return callback(err);
          }
        }

        return self._insert(toBeInserted, function (err, newDoc) {
          if (err) { return callback(err); }
          return callback(null, 1, newDoc, true);
        });
      }
    });
  }
  , function () {   // Perform the update
    var modifiedDoc , modifications = [], createdAt;

    self.getCandidates(query, function (err, candidates) {
      if (err) { return callback(err); }

      // Preparing update (if an error is thrown here neither the datafile nor
      // the in-memory indexes are affected)
      try {
        for (i = 0; i &#x3c; candidates.length; i += 1) {
          if (model.match(candidates[i], query) &#x26;&#x26; (multi || numReplaced === 0)) {
            numReplaced += 1;
            if (self.timestampData) { createdAt = candidates[i].createdAt; }
            modifiedDoc = model.modify(candidates[i], updateQuery);
            if (self.timestampData) {
              modifiedDoc.createdAt = createdAt;
              modifiedDoc.updatedAt = new Date();
            }
            modifications.push({ oldDoc: candidates[i], newDoc: modifiedDoc });
          }
        }
      } catch (err) {
        return callback(err);
      }

      // Change the docs in memory
      try {
        self.updateIndexes(modifications);
      } catch (err) {
        return callback(err);
      }

      // Update the datafile
      var updatedDocs = _.pluck(modifications, &#x27;newDoc&#x27;);
      self.persistence.persistNewState(updatedDocs, function (err) {
        if (err) { return callback(err); }
        if (!options.returnUpdatedDocs) {
          return callback(null, numReplaced);
        } else {
          var updatedDocsDC = [];
          updatedDocs.forEach(function (doc) { updatedDocsDC.push(model.deepCopy(doc)); });
          if (! multi) { updatedDocsDC = updatedDocsDC[0]; }
          return callback(null, numReplaced, updatedDocsDC);
        }
      });
    });
  }]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.datastore.prototype.addToIndexes" id="apidoc.element.nedb.datastore.prototype.addToIndexes">
        function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>addToIndexes
        <span class="apidocSignatureSpan">(doc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addToIndexes = function (doc) {
  var i, failingIndex, error
    , keys = Object.keys(this.indexes)
    ;

  for (i = 0; i &#x3c; keys.length; i += 1) {
    try {
      this.indexes[keys[i]].insert(doc);
    } catch (e) {
      failingIndex = i;
      error = e;
      break;
    }
  }

  // If an error happened, we need to rollback the insert on all other indexes
  if (error) {
    for (i = 0; i &#x3c; failingIndex; i += 1) {
      this.indexes[keys[i]].remove(doc);
    }

    throw error;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* If newDoc is an array of documents, this will insert all documents in the cache
* @api private
*/
Datastore.prototype._insertInCache = function (preparedDoc) {
 if (util.isArray(preparedDoc)) {
   this._insertMultipleDocsInCache(preparedDoc);
 } else {
   this.<span class="apidocCodeKeywordSpan">addToIndexes</span>(preparedDoc);
 }
};

/**
* If one insertion fails (e.g. because of a unique constraint), roll back all previous
* inserts and throws the error
* @api private
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.datastore.prototype.count" id="apidoc.element.nedb.datastore.prototype.count">
        function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>count
        <span class="apidocSignatureSpan">(query, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">count = function (query, callback) {
  var cursor = new Cursor(this, query, function(err, docs, callback) {
    if (err) { return callback(err); }
    return callback(null, docs.length);
  });

  if (typeof callback === &#x27;function&#x27;) {
    cursor.exec(callback);
  } else {
    return cursor;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


### Counting documents
You can use `count` to count documents. It has the same syntax as `find`. For example:

```javascript
// Count all planets in the solar system
db.<span class="apidocCodeKeywordSpan">count</span>({ system: &#x27;solar&#x27; }, function (err, count) {
  // count equals to 3
});

// Count all documents in the datastore
db.count({}, function (err, count) {
  // count equals to 4
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.datastore.prototype.createNewId" id="apidoc.element.nedb.datastore.prototype.createNewId">
        function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>createNewId
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createNewId = function () {
  var tentativeId = customUtils.uid(16);
  // Try as many times as needed to get an unused _id. As explained in customUtils, the probability of this ever happening is extremely
 small, so this is O(1)
  if (this.indexes._id.getMatching(tentativeId).length &#x3e; 0) {
    tentativeId = this.createNewId();
  }
  return tentativeId;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Create a new _id that&#x27;s not already in use
*/
Datastore.prototype.createNewId = function () {
 var tentativeId = customUtils.uid(16);
 // Try as many times as needed to get an unused _id. As explained in customUtils, the probability of this ever happening is extremely
 small, so this is O(1)
 if (this.indexes._id.getMatching(tentativeId).length &#x3e; 0) {
   tentativeId = this.<span class="apidocCodeKeywordSpan">createNewId</span>();
 }
 return tentativeId;
};

/**
* Prepare a document (or array of documents) to be inserted in a database
* Meaning adds _id and timestamps if necessary on a copy of newDoc to avoid any side effect on user input
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.datastore.prototype.ensureIndex" id="apidoc.element.nedb.datastore.prototype.ensureIndex">
        function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>ensureIndex
        <span class="apidocSignatureSpan">(options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ensureIndex = function (options, cb) {
  var err
    , callback = cb || function () {};

  options = options || {};

  if (!options.fieldName) {
    err = new Error(&#x22;Cannot create an index without a fieldName&#x22;);
    err.missingFieldName = true;
    return callback(err);
  }
  if (this.indexes[options.fieldName]) { return callback(null); }

  this.indexes[options.fieldName] = new Index(options);
  if (options.expireAfterSeconds !== undefined) { this.ttlIndexes[options.fieldName] = options.expireAfterSeconds; }   // With this
 implementation index creation is not necessary to ensure TTL but we stick with MongoDB&#x27;s API here

  try {
    this.indexes[options.fieldName].insert(this.getAllData());
  } catch (e) {
    delete this.indexes[options.fieldName];
    return callback(e);
  }

  // We may want to force all options to be persisted including defaults, not just the ones passed the index creation function
  this.persistence.persistNewState([{ $$indexCreated: options }], function (err) {
    if (err) { return callback(err); }
    return callback(null);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
db.remove({}, { multi: true }, function (err, numRemoved) {
});
```

### Indexing
NeDB supports indexing. It gives a very nice speed boost and can be used to enforce a unique constraint on a field. You can index
 any field, including fields in nested documents using the dot notation. For now, indexes are only used to speed up basic queries
 and queries using `$in`, `$lt`, `$lte`, `$gt` and `$gte`. The indexed values cannot be of type array of object.

To create an index, use `datastore.<span class="apidocCodeKeywordSpan">ensureIndex</span>(options, cb)`, where callback is optional
 and get passed an error if any (usually a unique constraint that was violated). `ensureIndex` can be called when you want, even
 after some data was inserted, though it&#x27;s best to call it at application startup. The options are:

* **fieldName** (required): name of the field to index. Use the dot notation to index a field in a nested document.
* **unique** (optional, defaults to `false`): enforce field uniqueness. Note that a unique index will raise an error if you try
to index two documents for which the field is not defined.
* **sparse** (optional, defaults to `false`): don&#x27;t index documents for which the field is not defined. Use this option along
 with &#x22;unique&#x22; if you want to accept multiple documents for which it is not defined.
* **expireAfterSeconds** (number of seconds, optional): if set, the created index is a TTL (time to live) index, that will automatically
 remove documents when the system date becomes larger than the date on the indexed field plus `expireAfterSeconds`. Documents where
 the indexed field is not specified or not a `Date` object are ignored

Note: the `_id` is automatically indexed with a unique constraint, no need to call `ensureIndex` on it.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.datastore.prototype.find" id="apidoc.element.nedb.datastore.prototype.find">
        function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>find
        <span class="apidocSignatureSpan">(query, projection, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">find = function (query, projection, callback) {
  switch (arguments.length) {
    case 1:
      projection = {};
      // callback is undefined, will return a cursor
      break;
    case 2:
      if (typeof projection === &#x27;function&#x27;) {
        callback = projection;
        projection = {};
      }   // If not assume projection is an object and callback undefined
      break;
  }

  var cursor = new Cursor(this, query, function(err, docs, callback) {
    var res = [], i;

    if (err) { return callback(err); }

    for (i = 0; i &#x3c; docs.length; i += 1) {
      res.push(model.deepCopy(docs[i]));
    }
    return callback(null, res);
  });

  cursor.projection(projection);
  if (typeof callback === &#x27;function&#x27;) {
    cursor.exec(callback);
  } else {
    return cursor;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// { _id: &#x27;id1&#x27;, planet: &#x27;Mars&#x27;, system: &#x27;solar&#x27;, inhabited: false, satellites: [&#x27;Phobos&#x27
;, &#x27;Deimos&#x27;] }
// { _id: &#x27;id2&#x27;, planet: &#x27;Earth&#x27;, system: &#x27;solar&#x27;, inhabited: true, humans: { genders: 2, eyes: true
 } }
// { _id: &#x27;id3&#x27;, planet: &#x27;Jupiter&#x27;, system: &#x27;solar&#x27;, inhabited: false }
// { _id: &#x27;id4&#x27;, planet: &#x27;Omicron Persei 8&#x27;, system: &#x27;futurama&#x27;, inhabited: true, humans: { genders
: 7 } }
// { _id: &#x27;id5&#x27;, completeData: { planets: [ { name: &#x27;Earth&#x27;, number: 3 }, { name: &#x27;Mars&#x27;, number:
2 }, { name: &#x27;Pluton&#x27;, number: 9 } ] } }

// Finding all planets in the solar system
db.<span class="apidocCodeKeywordSpan">find</span>({ system: &#x27;solar&#x27; }, function (err, docs) {
// docs is an array containing documents Mars, Earth, Jupiter
// If no document is found, docs is equal to []
});

// Finding all planets whose name contain the substring &#x27;ar&#x27; using a regular expression
db.find({ planet: /ar/ }, function (err, docs) {
// docs contains Mars and Earth
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.datastore.prototype.findOne" id="apidoc.element.nedb.datastore.prototype.findOne">
        function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>findOne
        <span class="apidocSignatureSpan">(query, projection, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findOne = function (query, projection, callback) {
  switch (arguments.length) {
    case 1:
      projection = {};
      // callback is undefined, will return a cursor
      break;
    case 2:
      if (typeof projection === &#x27;function&#x27;) {
        callback = projection;
        projection = {};
      }   // If not assume projection is an object and callback undefined
      break;
  }

  var cursor = new Cursor(this, query, function(err, docs, callback) {
    if (err) { return callback(err); }
    if (docs.length === 1) {
      return callback(null, model.deepCopy(docs[0]));
    } else {
      return callback(null, null);
    }
  });

  cursor.projection(projection).limit(1);
  if (typeof callback === &#x27;function&#x27;) {
    cursor.exec(callback);
  } else {
    return cursor;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});

// Find all documents in the collection
db.find({}, function (err, docs) {
});

// The same rules apply when you want to only find one document
db.<span class="apidocCodeKeywordSpan">findOne</span>({ _id: &#x27;id1&#x27; }, function (err, doc) {
  // doc is the document Mars
  // If no document is found, doc is null
});
```

#### Operators ($lt, $lte, $gt, $gte, $in, $nin, $ne, $exists, $regex)
The syntax is `{ field: { $op: value } }` where `$op` is any comparison operator:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.datastore.prototype.getAllData" id="apidoc.element.nedb.datastore.prototype.getAllData">
        function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>getAllData
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAllData = function () {
  return this.indexes._id.getAll();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
if (this.indexes[options.fieldName]) { return callback(null); }

this.indexes[options.fieldName] = new Index(options);
if (options.expireAfterSeconds !== undefined) { this.ttlIndexes[options.fieldName] = options.expireAfterSeconds; }   // With this
 implementation index creation is not necessary to ensure TTL but we stick with MongoDB&#x27;s API here

try {
  this.indexes[options.fieldName].insert(this.<span class="apidocCodeKeywordSpan">getAllData</span>());
} catch (e) {
  delete this.indexes[options.fieldName];
  return callback(e);
}

// We may want to force all options to be persisted including defaults, not just the ones passed the index creation function
this.persistence.persistNewState([{ $$indexCreated: options }], function (err) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.datastore.prototype.getCandidates" id="apidoc.element.nedb.datastore.prototype.getCandidates">
        function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>getCandidates
        <span class="apidocSignatureSpan">(query, dontExpireStaleDocs, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getCandidates = function (query, dontExpireStaleDocs, callback) {
  var indexNames = Object.keys(this.indexes)
    , self = this
    , usableQueryKeys;

  if (typeof dontExpireStaleDocs === &#x27;function&#x27;) {
    callback = dontExpireStaleDocs;
    dontExpireStaleDocs = false;
  }

  async.waterfall([
  // STEP 1: get candidates list by checking indexes from most to least frequent usecase
  function (cb) {
    // For a basic match
    usableQueryKeys = [];
    Object.keys(query).forEach(function (k) {
      if (typeof query[k] === &#x27;string&#x27; || typeof query[k] === &#x27;number&#x27; || typeof query[k] === &#x27;boolean&#x27; || util.isDate(query[k]) ||
query[k] === null) {
        usableQueryKeys.push(k);
      }
    });
    usableQueryKeys = _.intersection(usableQueryKeys, indexNames);
    if (usableQueryKeys.length &#x3e; 0) {
      return cb(null, self.indexes[usableQueryKeys[0]].getMatching(query[usableQueryKeys[0]]));
    }

    // For a $in match
    usableQueryKeys = [];
    Object.keys(query).forEach(function (k) {
      if (query[k] &#x26;&#x26; query[k].hasOwnProperty(&#x27;$in&#x27;)) {
        usableQueryKeys.push(k);
      }
    });
    usableQueryKeys = _.intersection(usableQueryKeys, indexNames);
    if (usableQueryKeys.length &#x3e; 0) {
      return cb(null, self.indexes[usableQueryKeys[0]].getMatching(query[usableQueryKeys[0]].$in));
    }

    // For a comparison match
    usableQueryKeys = [];
    Object.keys(query).forEach(function (k) {
      if (query[k] &#x26;&#x26; (query[k].hasOwnProperty(&#x27;$lt&#x27;) || query[k].hasOwnProperty(&#x27;$lte&#x27;) || query[k].hasOwnProperty(&#x27;$gt&#x27;) || query
[k].hasOwnProperty(&#x27;$gte&#x27;))) {
        usableQueryKeys.push(k);
      }
    });
    usableQueryKeys = _.intersection(usableQueryKeys, indexNames);
    if (usableQueryKeys.length &#x3e; 0) {
      return cb(null, self.indexes[usableQueryKeys[0]].getBetweenBounds(query[usableQueryKeys[0]]));
    }

    // By default, return all the DB data
    return cb(null, self.getAllData());
  }
  // STEP 2: remove all expired documents
  , function (docs) {
    if (dontExpireStaleDocs) { return callback(null, docs); }

    var expiredDocsIds = [], validDocs = [], ttlIndexesFieldNames = Object.keys(self.ttlIndexes);

    docs.forEach(function (doc) {
      var valid = true;
      ttlIndexesFieldNames.forEach(function (i) {
        if (doc[i] !== undefined &#x26;&#x26; util.isDate(doc[i]) &#x26;&#x26; Date.now() &#x3e; doc[i].getTime() + self.ttlIndexes[i] * 1000) {
          valid = false;
        }
      });
      if (valid) { validDocs.push(doc); } else { expiredDocsIds.push(doc._id); }
    });

    async.eachSeries(expiredDocsIds, function (_id, cb) {
      self._remove({ _id: _id }, {}, function (err) {
        if (err) { return callback(err); }
        return cb();
      });
    }, function (err) {
      return callback(null, validDocs);
    });
  }]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (self.execFn) {
  return self.execFn(error, res, _callback);
} else {
  return _callback(error, res);
}
  }

  this.db.<span class="apidocCodeKeywordSpan">getCandidates</span>(this.query, function (err, candidates) {
if (err) { return callback(err); }

try {
  for (i = 0; i &#x3c; candidates.length; i += 1) {
    if (model.match(candidates[i], self.query)) {
      // If a sort is defined, wait for the results to be sorted before applying limit and skip
      if (!self._sort) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.datastore.prototype.insert" id="apidoc.element.nedb.datastore.prototype.insert">
        function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>insert
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insert = function () {
  this.executor.push({ this: this, fn: this._insert, arguments: arguments });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
               , nedbIsAwesome: true
               , notthere: null
               , notToBeSaved: undefined  // Will not be saved
               , fruits: [ &#x27;apple&#x27;, &#x27;orange&#x27;, &#x27;pear&#x27; ]
               , infos: { name: &#x27;nedb&#x27; }
               };

db.<span class="apidocCodeKeywordSpan">insert</span>(doc, function (err, newDoc) {   // Callback is optional
  // newDoc is the newly inserted document, including its _id
  // newDoc has no key called notToBeSaved since its value was undefined
});
```

You can also bulk-insert an array of documents. This operation is atomic, meaning that if one insert fails due to a unique constraint
 being violated, all changes are rolled back.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.datastore.prototype.loadDatabase" id="apidoc.element.nedb.datastore.prototype.loadDatabase">
        function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>loadDatabase
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadDatabase = function () {
  this.executor.push({ this: this.persistence, fn: this.persistence.loadDatabase, arguments: arguments }, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var Datastore = require(&#x27;nedb&#x27;)
, db = new Datastore();


// Type 2: Persistent datastore with manual loading
var Datastore = require(&#x27;nedb&#x27;)
, db = new Datastore({ filename: &#x27;path/to/datafile&#x27; });
db.<span class="apidocCodeKeywordSpan">loadDatabase</span>(function (err) {    // Callback is optional
// Now commands will be executed
});


// Type 3: Persistent datastore with automatic loading
var Datastore = require(&#x27;nedb&#x27;)
, db = new Datastore({ filename: &#x27;path/to/datafile&#x27;, autoload: true });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.datastore.prototype.prepareDocumentForInsertion" id="apidoc.element.nedb.datastore.prototype.prepareDocumentForInsertion">
        function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>prepareDocumentForInsertion
        <span class="apidocSignatureSpan">(newDoc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prepareDocumentForInsertion = function (newDoc) {
  var preparedDoc, self = this;

  if (util.isArray(newDoc)) {
    preparedDoc = [];
    newDoc.forEach(function (doc) { preparedDoc.push(self.prepareDocumentForInsertion(doc)); });
  } else {
    preparedDoc = model.deepCopy(newDoc);
    if (preparedDoc._id === undefined) { preparedDoc._id = this.createNewId(); }
    var now = new Date();
    if (this.timestampData &#x26;&#x26; preparedDoc.createdAt === undefined) { preparedDoc.createdAt = now; }
    if (this.timestampData &#x26;&#x26; preparedDoc.updatedAt === undefined) { preparedDoc.updatedAt = now; }
    model.checkObject(preparedDoc);
  }

  return preparedDoc;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
Datastore.prototype._insert = function (newDoc, cb) {
var callback = cb || function () {}
  , preparedDoc
  ;

try {
  preparedDoc = this.<span class="apidocCodeKeywordSpan">prepareDocumentForInsertion</span>(newDoc)
  this._insertInCache(preparedDoc);
} catch (e) {
  return callback(e);
}

this.persistence.persistNewState(util.isArray(preparedDoc) ? preparedDoc : [preparedDoc], function (err) {
  if (err) { return callback(err); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.datastore.prototype.remove" id="apidoc.element.nedb.datastore.prototype.remove">
        function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>remove
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function () {
  this.executor.push({ this: this, fn: this._remove, arguments: arguments });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

db.update({ _id: &#x27;id1&#x27; }, { $min: { value: 8 } }, {}, function () {
  // The document will not be modified
});
```

### Removing documents
`db.<span class="apidocCodeKeywordSpan">remove</span>(query, options, callback)` will remove all documents matching `query` according
 to `options`
* `query` is the same as the ones used for finding and updating
* `options` only one option for now: `multi` which allows the removal of multiple documents if set to true. Default is false
* `callback` is optional, signature: err, numRemoved

```javascript
// Let&#x27;s use the same example collection as in the &#x22;finding document&#x22; part
// { _id: &#x27;id1&#x27;, planet: &#x27;Mars&#x27;, system: &#x27;solar&#x27;, inhabited: false }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.datastore.prototype.removeFromIndexes" id="apidoc.element.nedb.datastore.prototype.removeFromIndexes">
        function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>removeFromIndexes
        <span class="apidocSignatureSpan">(doc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeFromIndexes = function (doc) {
  var self = this;

  Object.keys(this.indexes).forEach(function (i) {
    self.indexes[i].remove(doc);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      failingI = i;
      break;
    }
  }

  if (error) {
    for (i = 0; i &#x3c; failingI; i += 1) {
      this.<span class="apidocCodeKeywordSpan">removeFromIndexes</span>(preparedDocs[i]);
    }

    throw error;
  }
};

Datastore.prototype.insert = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.datastore.prototype.removeIndex" id="apidoc.element.nedb.datastore.prototype.removeIndex">
        function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>removeIndex
        <span class="apidocSignatureSpan">(fieldName, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeIndex = function (fieldName, cb) {
  var callback = cb || function () {};

  delete this.indexes[fieldName];

  this.persistence.persistNewState([{ $$indexRemoved: fieldName }], function (err) {
    if (err) { return callback(err); }
    return callback(null);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* **fieldName** (required): name of the field to index. Use the dot notation to index a field in a nested document.
* **unique** (optional, defaults to `false`): enforce field uniqueness. Note that a unique index will raise an error if you try
to index two documents for which the field is not defined.
* **sparse** (optional, defaults to `false`): don&#x27;t index documents for which the field is not defined. Use this option along
 with &#x22;unique&#x22; if you want to accept multiple documents for which it is not defined.
* **expireAfterSeconds** (number of seconds, optional): if set, the created index is a TTL (time to live) index, that will automatically
 remove documents when the system date becomes larger than the date on the indexed field plus `expireAfterSeconds`. Documents where
 the indexed field is not specified or not a `Date` object are ignored

Note: the `_id` is automatically indexed with a unique constraint, no need to call `ensureIndex` on it.

You can remove a previously created index with `datastore.<span class="apidocCodeKeywordSpan">removeIndex</span>(fieldName, cb)`.

If your datastore is persistent, the indexes you created are persisted in the datafile, when you load the database a second time
 they are automatically created for you. No need to remove any `ensureIndex` though, if it is called on a database that already
has the index, nothing happens.

```javascript
db.ensureIndex({ fieldName: &#x27;somefield&#x27; }, function (err) {
  // If there was an error, err is not null
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.datastore.prototype.resetIndexes" id="apidoc.element.nedb.datastore.prototype.resetIndexes">
        function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>resetIndexes
        <span class="apidocSignatureSpan">(newData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resetIndexes = function (newData) {
  var self = this;

  Object.keys(this.indexes).forEach(function (i) {
    self.indexes[i].reset(newData);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Function} cb Optional callback, signature: err
 */
Persistence.prototype.loadDatabase = function (cb) {
var callback = cb || function () {}
  , self = this
  ;

self.db.<span class="apidocCodeKeywordSpan">resetIndexes</span>();

// In-memory only datastore
if (self.inMemoryOnly) { return callback(null); }

async.waterfall([
  function (cb) {
    Persistence.ensureDirectoryExists(path.dirname(self.filename), function (err) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.datastore.prototype.update" id="apidoc.element.nedb.datastore.prototype.update">
        function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>update
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update = function () {
  this.executor.push({ this: this, fn: this._update, arguments: arguments });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
db.count({}, function (err, count) {
// count equals to 4
});
```


### Updating documents
`db.<span class="apidocCodeKeywordSpan">update</span>(query, update, options, callback)` will update all documents matching `query
` according to the `update` rules:
* `query` is the same kind of finding query you use with `find` and `findOne`
* `update` specifies how the documents should be modified. It is either a new document or a set of modifiers (you cannot use both
 together, it doesn&#x27;t make sense!)
* A new document will replace the matched docs
* The modifiers create the fields they need to modify if they don&#x27;t exist, and you can apply them to subdocs. Available field
 modifiers are `$set` to change a field&#x27;s value, `$unset` to delete a field, `$inc` to increment a field&#x27;s value and `$
min`/`$max` to change field&#x27;s value, only if provided value is less/greater than current value. To work on arrays, you have
 `$push`, `$pop`, `$addToSet`, `$pull`, and the special `$each` and `$slice`. See examples below for the syntax.
* `options` is an object with two possible parameters
* `multi` (defaults to `false`) which allows the modification of several documents if set to true
* `upsert` (defaults to `false`) if you want to insert a new document corresponding to the `update` rules if your `query` doesn&#
x27;t match anything. If your `update` is a simple object with no modifiers, it is the inserted document. In the other case, the
 `query` is stripped from all operator recursively, and the `update` is applied to it.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.datastore.prototype.updateIndexes" id="apidoc.element.nedb.datastore.prototype.updateIndexes">
        function <span class="apidocSignatureSpan">nedb.datastore.prototype.</span>updateIndexes
        <span class="apidocSignatureSpan">(oldDoc, newDoc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateIndexes = function (oldDoc, newDoc) {
  var i, failingIndex, error
    , keys = Object.keys(this.indexes)
    ;

  for (i = 0; i &#x3c; keys.length; i += 1) {
    try {
      this.indexes[keys[i]].update(oldDoc, newDoc);
    } catch (e) {
      failingIndex = i;
      error = e;
      break;
    }
  }

  // If an error happened, we need to rollback the update on all other indexes
  if (error) {
    for (i = 0; i &#x3c; failingIndex; i += 1) {
      this.indexes[keys[i]].revertUpdate(oldDoc, newDoc);
    }

    throw error;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
} catch (err) {
  return callback(err);
}

// Change the docs in memory
try {
  self.<span class="apidocCodeKeywordSpan">updateIndexes</span>(modifications);
} catch (err) {
  return callback(err);
}

// Update the datafile
var updatedDocs = _.pluck(modifications, &#x27;newDoc&#x27;);
self.persistence.persistNewState(updatedDocs, function (err) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nedb.executor" id="apidoc.module.nedb.executor">module nedb.executor</a></h1>


    <h2>
        <a href="#apidoc.element.nedb.executor.executor" id="apidoc.element.nedb.executor.executor">
        function <span class="apidocSignatureSpan">nedb.</span>executor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Executor() {
  this.buffer = [];
  this.ready = false;

  // This queue will execute all commands, one-by-one in order
  this.queue = async.queue(function (task, cb) {
    var newArguments = [];

    // task.arguments is an array-like object on which adding a new field doesn&#x27;t work, so we transform it into a real array
    for (var i = 0; i &#x3c; task.arguments.length; i += 1) { newArguments.push(task.arguments[i]); }
    var lastArg = task.arguments[task.arguments.length - 1];

    // Always tell the queue task is complete. Execute callback if any was given.
    if (typeof lastArg === &#x27;function&#x27;) {
      // Callback was supplied
      newArguments[newArguments.length - 1] = function () {
        if (typeof setImmediate === &#x27;function&#x27;) {
           setImmediate(cb);
        } else {
          process.nextTick(cb);
        }
        lastArg.apply(null, arguments);
      };
    } else if (!lastArg &#x26;&#x26; task.arguments.length !== 0) {
      // false/undefined/null supplied as callbback
      newArguments[newArguments.length - 1] = function () { cb(); };
    } else {
      // Nothing supplied as callback
      newArguments.push(function () { cb(); });
    }


    task.fn.apply(task.this, newArguments);
  }, 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nedb.executor.prototype" id="apidoc.module.nedb.executor.prototype">module nedb.executor.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.nedb.executor.prototype.processBuffer" id="apidoc.element.nedb.executor.prototype.processBuffer">
        function <span class="apidocSignatureSpan">nedb.executor.prototype.</span>processBuffer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processBuffer = function () {
  var i;
  this.ready = true;
  for (i = 0; i &#x3c; this.buffer.length; i += 1) { this.queue.push(this.buffer[i]); }
  this.buffer = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          });
        });
      });
    }
  ], function (err) {
       if (err) { return callback(err); }

       self.db.executor.<span class="apidocCodeKeywordSpan">processBuffer</span>();
       return callback(null);
     });
};


// Interface
module.exports = Persistence;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.executor.prototype.push" id="apidoc.element.nedb.executor.prototype.push">
        function <span class="apidocSignatureSpan">nedb.executor.prototype.</span>push
        <span class="apidocSignatureSpan">(task, forceQueuing)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function (task, forceQueuing) {
  if (this.ready || forceQueuing) {
    this.queue.push(task);
  } else {
    this.buffer.push(task);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ;

// Preparing all the $in arrays, will take some time
for (i = 0; i &#x3c; n; i += 1) {
  ins[i] = [];

  for (j = 0; j &#x3c; arraySize; j += 1) {
    ins[i].<span class="apidocCodeKeywordSpan">push</span>((i + j) % n);
  }
}

profiler.step(&#x22;Finding &#x22; + n + &#x22; documents WITH $IN OPERATOR&#x22;);

function runFrom(i) {
  if (i === n) {   // Finished
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nedb.model" id="apidoc.module.nedb.model">module nedb.model</a></h1>


    <h2>
        <a href="#apidoc.element.nedb.model.areThingsEqual" id="apidoc.element.nedb.model.areThingsEqual">
        function <span class="apidocSignatureSpan">nedb.model.</span>areThingsEqual
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function areThingsEqual(a, b) {
  var aKeys , bKeys , i;

  // Strings, booleans, numbers, null
  if (a === null || typeof a === &#x27;string&#x27; || typeof a === &#x27;boolean&#x27; || typeof a === &#x27;number&#x27; ||
      b === null || typeof b === &#x27;string&#x27; || typeof b === &#x27;boolean&#x27; || typeof b === &#x27;number&#x27;) { return a === b; }

  // Dates
  if (util.isDate(a) || util.isDate(b)) { return util.isDate(a) &#x26;&#x26; util.isDate(b) &#x26;&#x26; a.getTime() === b.getTime(); }

  // Arrays (no match since arrays are used as a $in)
  // undefined (no match since they mean field doesn&#x27;t exist and can&#x27;t be serialized)
  if ((!(util.isArray(a) &#x26;&#x26; util.isArray(b)) &#x26;&#x26; (util.isArray(a) || util.isArray(b))) || a === undefined || b === undefined) { return
 false; }

  // General objects (check for deep equality)
  // a and b should be objects at this point
  try {
    aKeys = Object.keys(a);
    bKeys = Object.keys(b);
  } catch (e) {
    return false;
  }

  if (aKeys.length !== bKeys.length) { return false; }
  for (i = 0; i &#x3c; aKeys.length; i += 1) {
    if (bKeys.indexOf(aKeys[i]) === -1) { return false; }
    if (!areThingsEqual(a[aKeys[i]], b[aKeys[i]])) { return false; }
  }
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var toTest = [null, &#x27;somestring&#x27;, 42, true, new Date(72998322), { hello: &#x27;world&#x27; }]
    , toTestAgainst = [null, &#x27;somestring&#x27;, 42, true, new Date(72998322), { hello: &#x27;world&#x27; }]   // Use another
 array so that we don&#x27;t test pointer equality
    , i, j
    ;

  for (i = 0; i &#x3c; toTest.length; i += 1) {
    for (j = 0; j &#x3c; toTestAgainst.length; j += 1) {
      model.<span class="apidocCodeKeywordSpan">areThingsEqual</span>(toTest[i], toTestAgainst[j]).should.equal(i === j);
    }
  }
});

it(&#x27;Can test native types null undefined string number boolean date equality&#x27;, function () {
  var toTest = [null, undefined, &#x27;somestring&#x27;, 42, true, new Date(72998322), { hello: &#x27;world&#x27; }]
    , toTestAgainst = [undefined, null, &#x27;someotherstring&#x27;, 5, false, new Date(111111), { hello: &#x27;mars&#x27; }]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.model.checkObject" id="apidoc.element.nedb.model.checkObject">
        function <span class="apidocSignatureSpan">nedb.model.</span>checkObject
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkObject(obj) {
  if (util.isArray(obj)) {
    obj.forEach(function (o) {
      checkObject(o);
    });
  }

  if (typeof obj === &#x27;object&#x27; &#x26;&#x26; obj !== null) {
    Object.keys(obj).forEach(function (k) {
      checkKey(k, obj[k]);
      checkObject(obj[k]);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   newDoc.forEach(function (doc) { preparedDoc.push(self.prepareDocumentForInsertion(doc)); });
 } else {
   preparedDoc = model.deepCopy(newDoc);
   if (preparedDoc._id === undefined) { preparedDoc._id = this.createNewId(); }
   var now = new Date();
   if (this.timestampData &#x26;&#x26; preparedDoc.createdAt === undefined) { preparedDoc.createdAt = now; }
   if (this.timestampData &#x26;&#x26; preparedDoc.updatedAt === undefined) { preparedDoc.updatedAt = now; }
   model.<span class="apidocCodeKeywordSpan">checkObject</span>(preparedDoc);
 }

 return preparedDoc;
};

/**
* If newDoc is an array of documents, this will insert all documents in the cache
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.model.compareThings" id="apidoc.element.nedb.model.compareThings">
        function <span class="apidocSignatureSpan">nedb.model.</span>compareThings
        <span class="apidocSignatureSpan">(a, b, _compareStrings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compareThings(a, b, _compareStrings) {
  var aKeys, bKeys, comp, i
    , compareStrings = _compareStrings || compareNSB;

  // undefined
  if (a === undefined) { return b === undefined ? 0 : -1; }
  if (b === undefined) { return a === undefined ? 0 : 1; }

  // null
  if (a === null) { return b === null ? 0 : -1; }
  if (b === null) { return a === null ? 0 : 1; }

  // Numbers
  if (typeof a === &#x27;number&#x27;) { return typeof b === &#x27;number&#x27; ? compareNSB(a, b) : -1; }
  if (typeof b === &#x27;number&#x27;) { return typeof a === &#x27;number&#x27; ? compareNSB(a, b) : 1; }

  // Strings
  if (typeof a === &#x27;string&#x27;) { return typeof b === &#x27;string&#x27; ? compareStrings(a, b) : -1; }
  if (typeof b === &#x27;string&#x27;) { return typeof a === &#x27;string&#x27; ? compareStrings(a, b) : 1; }

  // Booleans
  if (typeof a === &#x27;boolean&#x27;) { return typeof b === &#x27;boolean&#x27; ? compareNSB(a, b) : -1; }
  if (typeof b === &#x27;boolean&#x27;) { return typeof a === &#x27;boolean&#x27; ? compareNSB(a, b) : 1; }

  // Dates
  if (util.isDate(a)) { return util.isDate(b) ? compareNSB(a.getTime(), b.getTime()) : -1; }
  if (util.isDate(b)) { return util.isDate(a) ? compareNSB(a.getTime(), b.getTime()) : 1; }

  // Arrays (first element is most significant and so on)
  if (util.isArray(a)) { return util.isArray(b) ? compareArrays(a, b) : -1; }
  if (util.isArray(b)) { return util.isArray(a) ? compareArrays(a, b) : 1; }

  // Objects
  aKeys = Object.keys(a).sort();
  bKeys = Object.keys(b).sort();

  for (i = 0; i &#x3c; Math.min(aKeys.length, bKeys.length); i += 1) {
    comp = compareThings(a[aKeys[i]], b[bKeys[i]]);

    if (comp !== 0) { return comp; }
  }

  return compareNSB(aKeys.length, bKeys.length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  key = keys[i];
  criteria.push({ key: key, direction: self._sort[key] });
}
res.sort(function(a, b) {
  var criterion, compare, i;
  for (i = 0; i &#x3c; criteria.length; i++) {
    criterion = criteria[i];
    compare = criterion.direction * model.<span class="apidocCodeKeywordSpan">compareThings</span>(model.getDotValue(a, criterion
.key), model.getDotValue(b, criterion.key), self.db.compareStrings);
    if (compare !== 0) {
      return compare;
    }
  }
  return 0;
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.model.deepCopy" id="apidoc.element.nedb.model.deepCopy">
        function <span class="apidocSignatureSpan">nedb.model.</span>deepCopy
        <span class="apidocSignatureSpan">(obj, strictKeys)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deepCopy(obj, strictKeys) {
  var res;

  if ( typeof obj === &#x27;boolean&#x27; ||
       typeof obj === &#x27;number&#x27; ||
       typeof obj === &#x27;string&#x27; ||
       obj === null ||
       (util.isDate(obj)) ) {
    return obj;
  }

  if (util.isArray(obj)) {
    res = [];
    obj.forEach(function (o) { res.push(deepCopy(o, strictKeys)); });
    return res;
  }

  if (typeof obj === &#x27;object&#x27;) {
    res = {};
    Object.keys(obj).forEach(function (k) {
      if (!strictKeys || (k[0] !== &#x27;$&#x27; &#x26;&#x26; k.indexOf(&#x27;.&#x27;) === -1)) {
        res[k] = deepCopy(obj[k], strictKeys);
      }
    });
    return res;
  }

  return undefined;   // For now everything else is undefined. We should probably throw an error instead
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this._insertInCache(preparedDoc);
  } catch (e) {
    return callback(e);
  }

  this.persistence.persistNewState(util.isArray(preparedDoc) ? preparedDoc : [preparedDoc], function (err) {
    if (err) { return callback(err); }
    return callback(null, model.<span class="apidocCodeKeywordSpan">deepCopy</span>(preparedDoc));
  });
};

/**
 * Create a new _id that&#x27;s not already in use
 */
Datastore.prototype.createNewId = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.model.deserialize" id="apidoc.element.nedb.model.deserialize">
        function <span class="apidocSignatureSpan">nedb.model.</span>deserialize
        <span class="apidocSignatureSpan">(rawData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deserialize(rawData) {
  return JSON.parse(rawData, function (k, v) {
    if (k === &#x27;$$date&#x27;) { return new Date(v); }
    if (typeof v === &#x27;string&#x27; || typeof v === &#x27;number&#x27; || typeof v === &#x27;boolean&#x27; || v === null) { return v; }
    if (v &#x26;&#x26; v.$$date) { return v.$$date; }

    return v;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
, corruptItems = -1   // Last line of every data file is usually blank so not really corrupt
;

  for (i = 0; i &#x3c; data.length; i += 1) {
var doc;

try {
  doc = model.<span class="apidocCodeKeywordSpan">deserialize</span>(this.beforeDeserialization(data[i]));
  if (doc._id) {
    if (doc.$$deleted === true) {
      delete dataById[doc._id];
    } else {
      dataById[doc._id] = doc;
    }
  } else if (doc.$$indexCreated &#x26;&#x26; doc.$$indexCreated.fieldName != undefined) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.model.getDotValue" id="apidoc.element.nedb.model.getDotValue">
        function <span class="apidocSignatureSpan">nedb.model.</span>getDotValue
        <span class="apidocSignatureSpan">(obj, field)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDotValue(obj, field) {
  var fieldParts = typeof field === &#x27;string&#x27; ? field.split(&#x27;.&#x27;) : field
    , i, objs;

  if (!obj) { return undefined; }   // field cannot be empty so that means we should return undefined so that nothing can match

  if (fieldParts.length === 0) { return obj; }

  if (fieldParts.length === 1) { return obj[fieldParts[0]]; }

  if (util.isArray(obj[fieldParts[0]])) {
    // If the next field is an integer, return only this item of the array
    i = parseInt(fieldParts[1], 10);
    if (typeof i === &#x27;number&#x27; &#x26;&#x26; !isNaN(i)) {
      return getDotValue(obj[fieldParts[0]][i], fieldParts.slice(2))
    }

    // Return the array of values
    objs = new Array();
    for (i = 0; i &#x3c; obj[fieldParts[0]].length; i += 1) {
       objs.push(getDotValue(obj[fieldParts[0]][i], fieldParts.slice(1)));
    }
    return objs;
  } else {
    return getDotValue(obj[fieldParts[0]], fieldParts.slice(1));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Do the actual projection
candidates.forEach(function (candidate) {
  var toPush;
  if (action === 1) {   // pick-type projection
    toPush = { $set: {} };
    keys.forEach(function (k) {
      toPush.$set[k] = model.<span class="apidocCodeKeywordSpan">getDotValue</span>(candidate, k);
      if (toPush.$set[k] === undefined) { delete toPush.$set[k]; }
    });
    toPush = model.modify({}, toPush);
  } else {   // omit-type projection
    toPush = { $unset: {} };
    keys.forEach(function (k) { toPush.$unset[k] = true });
    toPush = model.modify(candidate, toPush);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.model.isPrimitiveType" id="apidoc.element.nedb.model.isPrimitiveType">
        function <span class="apidocSignatureSpan">nedb.model.</span>isPrimitiveType
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isPrimitiveType(obj) {
  return ( typeof obj === &#x27;boolean&#x27; ||
       typeof obj === &#x27;number&#x27; ||
       typeof obj === &#x27;string&#x27; ||
       obj === null ||
       util.isDate(obj) ||
       util.isArray(obj));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
it(&#x27;Properties with a null value dont trigger an error&#x27;, function () {
  var obj = { prop: null };

  model.checkObject(obj);
});

it(&#x27;Can check if an object is a primitive or not&#x27;, function () {
  model.<span class="apidocCodeKeywordSpan">isPrimitiveType</span>(5).should.equal(true);
  model.isPrimitiveType(&#x27;sdsfdfs&#x27;).should.equal(true);
  model.isPrimitiveType(0).should.equal(true);
  model.isPrimitiveType(true).should.equal(true);
  model.isPrimitiveType(false).should.equal(true);
  model.isPrimitiveType(new Date()).should.equal(true);
  model.isPrimitiveType([]).should.equal(true);
  model.isPrimitiveType([3, &#x27;try&#x27;]).should.equal(true);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.model.match" id="apidoc.element.nedb.model.match">
        function <span class="apidocSignatureSpan">nedb.model.</span>match
        <span class="apidocSignatureSpan">(obj, query)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function match(obj, query) {
  var queryKeys, queryKey, queryValue, i;

  // Primitive query against a primitive type
  // This is a bit of a hack since we construct an object with an arbitrary key only to dereference it later
  // But I don&#x27;t have time for a cleaner implementation now
  if (isPrimitiveType(obj) || isPrimitiveType(query)) {
    return matchQueryPart({ needAKey: obj }, &#x27;needAKey&#x27;, query);
  }

  // Normal query
  queryKeys = Object.keys(query);
  for (i = 0; i &#x3c; queryKeys.length; i += 1) {
    queryKey = queryKeys[i];
    queryValue = query[queryKey];

    if (queryKey[0] === &#x27;$&#x27;) {
      if (!logicalOperators[queryKey]) { throw new Error(&#x22;Unknown logical operator &#x22; + queryKey); }
      if (!logicalOperators[queryKey](obj, queryValue)) { return false; }
    } else {
      if (!matchQueryPart(obj, queryKey, queryValue)) { return false; }
    }
  }

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  this.db.getCandidates(this.query, function (err, candidates) {
if (err) { return callback(err); }

try {
  for (i = 0; i &#x3c; candidates.length; i += 1) {
    if (model.<span class="apidocCodeKeywordSpan">match</span>(candidates[i], self.query)) {
      // If a sort is defined, wait for the results to be sorted before applying limit and skip
      if (!self._sort) {
        if (self._skip &#x26;&#x26; self._skip &#x3e; skipped) {
          skipped += 1;
        } else {
          res.push(candidates[i]);
          added += 1;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.model.modify" id="apidoc.element.nedb.model.modify">
        function <span class="apidocSignatureSpan">nedb.model.</span>modify
        <span class="apidocSignatureSpan">(obj, updateQuery)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function modify(obj, updateQuery) {
  var keys = Object.keys(updateQuery)
    , firstChars = _.map(keys, function (item) { return item[0]; })
    , dollarFirstChars = _.filter(firstChars, function (c) { return c === &#x27;$&#x27;; })
    , newDoc, modifiers
    ;

  if (keys.indexOf(&#x27;_id&#x27;) !== -1 &#x26;&#x26; updateQuery._id !== obj._id) { throw new Error(&#x22;You cannot change a document&#x27;s _id&#x22;); }

  if (dollarFirstChars.length !== 0 &#x26;&#x26; dollarFirstChars.length !== firstChars.length) {
    throw new Error(&#x22;You cannot mix modifiers and normal fields&#x22;);
  }

  if (dollarFirstChars.length === 0) {
    // Simply replace the object with the update query contents
    newDoc = deepCopy(updateQuery);
    newDoc._id = obj._id;
  } else {
    // Apply modifiers
    modifiers = _.uniq(keys);
    newDoc = deepCopy(obj);
    modifiers.forEach(function (m) {
      var keys;

      if (!modifierFunctions[m]) { throw new Error(&#x22;Unknown modifier &#x22; + m); }

      // Can&#x27;t rely on Object.keys throwing on non objects since ES6
      // Not 100% satisfying as non objects can be interpreted as objects but no false negatives so we can live with it
      if (typeof updateQuery[m] !== &#x27;object&#x27;) {
        throw new Error(&#x22;Modifier &#x22; + m + &#x22;&#x27;s argument must be an object&#x22;);
      }

      keys = Object.keys(updateQuery[m]);
      keys.forEach(function (k) {
        modifierFunctions[m](newDoc, k, updateQuery[m][k]);
      });
    });
  }

  // Check result is valid and return it
  checkObject(newDoc);

  if (obj._id !== newDoc._id) { throw new Error(&#x22;You can&#x27;t change a document&#x27;s _id&#x22;); }
  return newDoc;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var toPush;
if (action === 1) {   // pick-type projection
  toPush = { $set: {} };
  keys.forEach(function (k) {
    toPush.$set[k] = model.getDotValue(candidate, k);
    if (toPush.$set[k] === undefined) { delete toPush.$set[k]; }
  });
  toPush = model.<span class="apidocCodeKeywordSpan">modify</span>({}, toPush);
} else {   // omit-type projection
  toPush = { $unset: {} };
  keys.forEach(function (k) { toPush.$unset[k] = true });
  toPush = model.modify(candidate, toPush);
}
if (keepId) {
  toPush._id = candidate._id;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.model.serialize" id="apidoc.element.nedb.model.serialize">
        function <span class="apidocSignatureSpan">nedb.model.</span>serialize
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function serialize(obj) {
  var res;

  res = JSON.stringify(obj, function (k, v) {
    checkKey(k, v);

    if (v === undefined) { return undefined; }
    if (v === null) { return null; }

    // Hackish way of checking if object is Date (this way it works between execution contexts in node-webkit).
    // We can&#x27;t use value directly because for dates it is already string in this function (date.toJSON was already called), so
we use this
    if (typeof this[k].getTime === &#x27;function&#x27;) { return { $$date: this[k].getTime() }; }

    return v;
  });

  return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  , toPersist = &#x27;&#x27;
  , self = this
  ;

if (this.inMemoryOnly) { return callback(null); }

this.db.getAllData().forEach(function (doc) {
  toPersist += self.afterSerialization(model.<span class="apidocCodeKeywordSpan">serialize</span>(doc)) + &#x27;\n&#x27;;
});
Object.keys(this.db.indexes).forEach(function (fieldName) {
  if (fieldName != &#x22;_id&#x22;) {   // The special _id index is managed by datastore.js, the others need to be persisted
    toPersist += self.afterSerialization(model.serialize({ $$indexCreated: { fieldName: fieldName, unique: self.db.indexes[fieldName
].unique, sparse: self.db.indexes[fieldName].sparse }})) + &#x27;\n&#x27;;
  }
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nedb.persistence" id="apidoc.module.nedb.persistence">module nedb.persistence</a></h1>


    <h2>
        <a href="#apidoc.element.nedb.persistence.persistence" id="apidoc.element.nedb.persistence.persistence">
        function <span class="apidocSignatureSpan">nedb.</span>persistence
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Persistence(options) {
  var i, j, randomString;

  this.db = options.db;
  this.inMemoryOnly = this.db.inMemoryOnly;
  this.filename = this.db.filename;
  this.corruptAlertThreshold = options.corruptAlertThreshold !== undefined ? options.corruptAlertThreshold : 0.1;

  if (!this.inMemoryOnly &#x26;&#x26; this.filename &#x26;&#x26; this.filename.charAt(this.filename.length - 1) === &#x27;~&#x27;) {
    throw new Error(&#x22;The datafile name can&#x27;t end with a ~, which is reserved for crash safe backup files&#x22;);
  }

  // After serialization and before deserialization hooks with some basic sanity checks
  if (options.afterSerialization &#x26;&#x26; !options.beforeDeserialization) {
    throw new Error(&#x22;Serialization hook defined but deserialization hook undefined, cautiously refusing to start NeDB to prevent
 dataloss&#x22;);
  }
  if (!options.afterSerialization &#x26;&#x26; options.beforeDeserialization) {
    throw new Error(&#x22;Serialization hook undefined but deserialization hook defined, cautiously refusing to start NeDB to prevent
 dataloss&#x22;);
  }
  this.afterSerialization = options.afterSerialization || function (s) { return s; };
  this.beforeDeserialization = options.beforeDeserialization || function (s) { return s; };
  for (i = 1; i &#x3c; 30; i += 1) {
    for (j = 0; j &#x3c; 10; j += 1) {
      randomString = customUtils.uid(i);
      if (this.beforeDeserialization(this.afterSerialization(randomString)) !== randomString) {
        throw new Error(&#x22;beforeDeserialization is not the reverse of afterSerialization, cautiously refusing to start NeDB to prevent
 dataloss&#x22;);
      }
    }
  }

  // For NW apps, store data in the same directory where NW stores application data
  if (this.filename &#x26;&#x26; options.nodeWebkitAppName) {
    console.log(&#x22;==================================================================&#x22;);
    console.log(&#x22;WARNING: The nodeWebkitAppName option is deprecated&#x22;);
    console.log(&#x22;To get the path to the directory where Node Webkit stores the data&#x22;);
    console.log(&#x22;for your app, use the internal nw.gui module like this&#x22;);
    console.log(&#x22;require(&#x27;nw.gui&#x27;).App.dataPath&#x22;);
    console.log(&#x22;See https://github.com/rogerwang/node-webkit/issues/500&#x22;);
    console.log(&#x22;==================================================================&#x22;);
    this.filename = Persistence.getNWAppFilename(options.nodeWebkitAppName, this.filename);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.persistence.ensureDirectoryExists" id="apidoc.element.nedb.persistence.ensureDirectoryExists">
        function <span class="apidocSignatureSpan">nedb.persistence.</span>ensureDirectoryExists
        <span class="apidocSignatureSpan">(dir, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ensureDirectoryExists = function (dir, cb) {
  var callback = cb || function () {}
    ;

  storage.mkdirp(dir, function (err) { return callback(err); });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};


/**
 * Ensure the workspace exists and the db datafile is empty
 */
module.exports.prepareDb = function (filename, cb) {
  Persistence.<span class="apidocCodeKeywordSpan">ensureDirectoryExists</span>(path.dirname(filename), function () {
    fs.exists(filename, function (exists) {
      if (exists) {
        fs.unlink(filename, cb);
      } else { return cb(); }
    });
  });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.persistence.getNWAppFilename" id="apidoc.element.nedb.persistence.getNWAppFilename">
        function <span class="apidocSignatureSpan">nedb.persistence.</span>getNWAppFilename
        <span class="apidocSignatureSpan">(appName, relativeFilename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getNWAppFilename = function (appName, relativeFilename) {
  var home;

  switch (process.platform) {
    case &#x27;win32&#x27;:
    case &#x27;win64&#x27;:
      home = process.env.LOCALAPPDATA || process.env.APPDATA;
      if (!home) { throw new Error(&#x22;Couldn&#x27;t find the base application data folder&#x22;); }
      home = path.join(home, appName);
      break;
    case &#x27;darwin&#x27;:
      home = process.env.HOME;
      if (!home) { throw new Error(&#x22;Couldn&#x27;t find the base application data directory&#x22;); }
      home = path.join(home, &#x27;Library&#x27;, &#x27;Application Support&#x27;, appName);
      break;
    case &#x27;linux&#x27;:
      home = process.env.HOME;
      if (!home) { throw new Error(&#x22;Couldn&#x27;t find the base application data directory&#x22;); }
      home = path.join(home, &#x27;.config&#x27;, appName);
      break;
    default:
      throw new Error(&#x22;Can&#x27;t use the Node Webkit relative path for platform &#x22; + process.platform);
      break;
  }

  return path.join(home, &#x27;nedb-data&#x27;, relativeFilename);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   console.log(&#x22;==================================================================&#x22;);
   console.log(&#x22;WARNING: The nodeWebkitAppName option is deprecated&#x22;);
   console.log(&#x22;To get the path to the directory where Node Webkit stores the data&#x22;);
   console.log(&#x22;for your app, use the internal nw.gui module like this&#x22;);
   console.log(&#x22;require(&#x27;nw.gui&#x27;).App.dataPath&#x22;);
   console.log(&#x22;See https://github.com/rogerwang/node-webkit/issues/500&#x22;);
   console.log(&#x22;==================================================================&#x22;);
   this.filename = Persistence.<span class="apidocCodeKeywordSpan">getNWAppFilename</span>(options.nodeWebkitAppName, this.filename
);
 }
};


/**
* Check if a directory exists and create it on the fly if it is not the case
* cb is optional, signature: err
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nedb.persistence.prototype" id="apidoc.module.nedb.persistence.prototype">module nedb.persistence.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.nedb.persistence.prototype.compactDatafile" id="apidoc.element.nedb.persistence.prototype.compactDatafile">
        function <span class="apidocSignatureSpan">nedb.persistence.prototype.</span>compactDatafile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compactDatafile = function () {
  this.db.executor.push({ this: this, fn: this.persistCachedDatabase, arguments: [] });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   , minInterval = 5000
   , realInterval = Math.max(interval || 0, minInterval)
   ;

 this.stopAutocompaction();

 this.autocompactionIntervalId = setInterval(function () {
   self.<span class="apidocCodeKeywordSpan">compactDatafile</span>();
 }, realInterval);
};


/**
* Stop autocompaction (do nothing if autocompaction was not running)
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.persistence.prototype.loadDatabase" id="apidoc.element.nedb.persistence.prototype.loadDatabase">
        function <span class="apidocSignatureSpan">nedb.persistence.prototype.</span>loadDatabase
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadDatabase = function (cb) {
  var callback = cb || function () {}
    , self = this
    ;

  self.db.resetIndexes();

  // In-memory only datastore
  if (self.inMemoryOnly) { return callback(null); }

  async.waterfall([
    function (cb) {
      Persistence.ensureDirectoryExists(path.dirname(self.filename), function (err) {
        storage.ensureDatafileIntegrity(self.filename, function (err) {
          storage.readFile(self.filename, &#x27;utf8&#x27;, function (err, rawData) {
            if (err) { return cb(err); }

            try {
              var treatedData = self.treatRawData(rawData);
            } catch (e) {
              return cb(e);
            }

            // Recreate all indexes in the datafile
            Object.keys(treatedData.indexes).forEach(function (key) {
              self.db.indexes[key] = new Index(treatedData.indexes[key]);
            });

            // Fill cached database (i.e. all indexes) with data
            try {
              self.db.resetIndexes(treatedData.data);
            } catch (e) {
              self.db.resetIndexes();   // Rollback any index which didn&#x27;t fail
              return cb(e);
            }

            self.db.persistence.persistCachedDatabase(cb);
          });
        });
      });
    }
  ], function (err) {
       if (err) { return callback(err); }

       self.db.executor.processBuffer();
       return callback(null);
     });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var Datastore = require(&#x27;nedb&#x27;)
, db = new Datastore();


// Type 2: Persistent datastore with manual loading
var Datastore = require(&#x27;nedb&#x27;)
, db = new Datastore({ filename: &#x27;path/to/datafile&#x27; });
db.<span class="apidocCodeKeywordSpan">loadDatabase</span>(function (err) {    // Callback is optional
// Now commands will be executed
});


// Type 3: Persistent datastore with automatic loading
var Datastore = require(&#x27;nedb&#x27;)
, db = new Datastore({ filename: &#x27;path/to/datafile&#x27;, autoload: true });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.persistence.prototype.persistCachedDatabase" id="apidoc.element.nedb.persistence.prototype.persistCachedDatabase">
        function <span class="apidocSignatureSpan">nedb.persistence.prototype.</span>persistCachedDatabase
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">persistCachedDatabase = function (cb) {
  var callback = cb || function () {}
    , toPersist = &#x27;&#x27;
    , self = this
    ;

  if (this.inMemoryOnly) { return callback(null); }

  this.db.getAllData().forEach(function (doc) {
    toPersist += self.afterSerialization(model.serialize(doc)) + &#x27;\n&#x27;;
  });
  Object.keys(this.db.indexes).forEach(function (fieldName) {
    if (fieldName != &#x22;_id&#x22;) {   // The special _id index is managed by datastore.js, the others need to be persisted
      toPersist += self.afterSerialization(model.serialize({ $$indexCreated: { fieldName: fieldName, unique: self.db.indexes[fieldName
].unique, sparse: self.db.indexes[fieldName].sparse }})) + &#x27;\n&#x27;;
    }
  });

  storage.crashSafeWriteFile(this.filename, toPersist, function (err) {
    if (err) { return callback(err); }
    self.db.emit(&#x27;compaction.done&#x27;);
    return callback(null);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          try {
            self.db.resetIndexes(treatedData.data);
          } catch (e) {
            self.db.resetIndexes();   // Rollback any index which didn&#x27;t fail
            return cb(e);
          }

          self.db.persistence.<span class="apidocCodeKeywordSpan">persistCachedDatabase</span>(cb);
        });
      });
    });
  }
], function (err) {
     if (err) { return callback(err); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.persistence.prototype.persistNewState" id="apidoc.element.nedb.persistence.prototype.persistNewState">
        function <span class="apidocSignatureSpan">nedb.persistence.prototype.</span>persistNewState
        <span class="apidocSignatureSpan">(newDocs, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">persistNewState = function (newDocs, cb) {
  var self = this
    , toPersist = &#x27;&#x27;
    , callback = cb || function () {}
    ;

  // In-memory only datastore
  if (self.inMemoryOnly) { return callback(null); }

  newDocs.forEach(function (doc) {
    toPersist += self.afterSerialization(model.serialize(doc)) + &#x27;\n&#x27;;
  });

  if (toPersist.length === 0) { return callback(null); }

  storage.appendFile(self.filename, toPersist, &#x27;utf8&#x27;, function (err) {
    return callback(err);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.indexes[options.fieldName].insert(this.getAllData());
  } catch (e) {
    delete this.indexes[options.fieldName];
    return callback(e);
  }

  // We may want to force all options to be persisted including defaults, not just the ones passed the index creation function
  this.persistence.<span class="apidocCodeKeywordSpan">persistNewState</span>([{ $$indexCreated: options }], function (err) {
    if (err) { return callback(err); }
    return callback(null);
  });
};


/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.persistence.prototype.setAutocompactionInterval" id="apidoc.element.nedb.persistence.prototype.setAutocompactionInterval">
        function <span class="apidocSignatureSpan">nedb.persistence.prototype.</span>setAutocompactionInterval
        <span class="apidocSignatureSpan">(interval)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setAutocompactionInterval = function (interval) {
  var self = this
    , minInterval = 5000
    , realInterval = Math.max(interval || 0, minInterval)
    ;

  this.stopAutocompaction();

  this.autocompactionIntervalId = setInterval(function () {
    self.compactDatafile();
  }, realInterval);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

### Persistence
Under the hood, NeDB&#x27;s persistence uses an append-only format, meaning that all updates and deletes actually result in lines
 added at the end of the datafile, for performance reasons. The database is automatically compacted (i.e. put back in the one-line
-per-document format) every time you load each database within your application.

You can manually call the compaction function with `yourDatabase.persistence.compactDatafile` which takes no argument. It queues
 a compaction of the datafile in the executor, to be executed sequentially after all pending operations. The datastore will fire
 a `compaction.done` event once compaction is finished.

You can also set automatic compaction at regular intervals with `yourDatabase.persistence.<span class="apidocCodeKeywordSpan">setAutocompactionInterval
</span>(interval)`, `interval` in milliseconds (a minimum of 5s is enforced), and stop automatic compaction with `yourDatabase.persistence
.stopAutocompaction()`.

Keep in mind that compaction takes a bit of time (not too much: 130ms for 50k records on a typical development machine) and no other
 operation can happen when it does, so most projects actually don&#x27;t need to use it.

Compaction will also immediately remove any documents whose data line has become corrupted, assuming that the total percentage of
 all corrupted documents in that database still falls below the specified `corruptAlertThreshold` option&#x27;s value.

Durability works similarly to major databases: compaction forces the OS to physically flush data to disk, while appends to the data
 file do not (the OS is responsible for flushing the data). That guarantees that a server crash can never cause complete data loss
, while preserving performance. The worst that can happen is a crash between two syncs, causing a loss of all data between the two
 syncs. Usually syncs are 30 seconds appart so that&#x27;s at most 30 seconds of data. &#x3c;a href=&#x22;http://oldblog.antirez
.com/post/redis-persistence-demystified.html&#x22; target=&#x22;_blank&#x22;&#x3e;This post by Antirez on Redis persistence&#x3c
;/a&#x3e; explains this in more details, NeDB being very close to Redis AOF persistence with `appendfsync` option set to `no`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.persistence.prototype.stopAutocompaction" id="apidoc.element.nedb.persistence.prototype.stopAutocompaction">
        function <span class="apidocSignatureSpan">nedb.persistence.prototype.</span>stopAutocompaction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stopAutocompaction = function () {
  if (this.autocompactionIntervalId) { clearInterval(this.autocompactionIntervalId); }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

### Persistence
Under the hood, NeDB&#x27;s persistence uses an append-only format, meaning that all updates and deletes actually result in lines
 added at the end of the datafile, for performance reasons. The database is automatically compacted (i.e. put back in the one-line
-per-document format) every time you load each database within your application.

You can manually call the compaction function with `yourDatabase.persistence.compactDatafile` which takes no argument. It queues
 a compaction of the datafile in the executor, to be executed sequentially after all pending operations. The datastore will fire
 a `compaction.done` event once compaction is finished.

You can also set automatic compaction at regular intervals with `yourDatabase.persistence.setAutocompactionInterval(interval)`, `
interval` in milliseconds (a minimum of 5s is enforced), and stop automatic compaction with `yourDatabase.persistence.<span class
="apidocCodeKeywordSpan">stopAutocompaction</span>()`.

Keep in mind that compaction takes a bit of time (not too much: 130ms for 50k records on a typical development machine) and no other
 operation can happen when it does, so most projects actually don&#x27;t need to use it.

Compaction will also immediately remove any documents whose data line has become corrupted, assuming that the total percentage of
 all corrupted documents in that database still falls below the specified `corruptAlertThreshold` option&#x27;s value.

Durability works similarly to major databases: compaction forces the OS to physically flush data to disk, while appends to the data
 file do not (the OS is responsible for flushing the data). That guarantees that a server crash can never cause complete data loss
, while preserving performance. The worst that can happen is a crash between two syncs, causing a loss of all data between the two
 syncs. Usually syncs are 30 seconds appart so that&#x27;s at most 30 seconds of data. &#x3c;a href=&#x22;http://oldblog.antirez
.com/post/redis-persistence-demystified.html&#x22; target=&#x22;_blank&#x22;&#x3e;This post by Antirez on Redis persistence&#x3c
;/a&#x3e; explains this in more details, NeDB being very close to Redis AOF persistence with `appendfsync` option set to `no`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.persistence.prototype.treatRawData" id="apidoc.element.nedb.persistence.prototype.treatRawData">
        function <span class="apidocSignatureSpan">nedb.persistence.prototype.</span>treatRawData
        <span class="apidocSignatureSpan">(rawData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">treatRawData = function (rawData) {
  var data = rawData.split(&#x27;\n&#x27;)
    , dataById = {}
    , tdata = []
    , i
    , indexes = {}
    , corruptItems = -1   // Last line of every data file is usually blank so not really corrupt
    ;

  for (i = 0; i &#x3c; data.length; i += 1) {
    var doc;

    try {
      doc = model.deserialize(this.beforeDeserialization(data[i]));
      if (doc._id) {
        if (doc.$$deleted === true) {
          delete dataById[doc._id];
        } else {
          dataById[doc._id] = doc;
        }
      } else if (doc.$$indexCreated &#x26;&#x26; doc.$$indexCreated.fieldName != undefined) {
        indexes[doc.$$indexCreated.fieldName] = doc.$$indexCreated;
      } else if (typeof doc.$$indexRemoved === &#x22;string&#x22;) {
        delete indexes[doc.$$indexRemoved];
      }
    } catch (e) {
      corruptItems += 1;
    }
  }

  // A bit lenient on corruption
  if (data.length &#x3e; 0 &#x26;&#x26; corruptItems / data.length &#x3e; this.corruptAlertThreshold) {
    throw new Error(&#x22;More than &#x22; + Math.floor(100 * this.corruptAlertThreshold) + &#x22;% of the data file is corrupt, the wrong beforeDeserialization
 hook may be used. Cautiously refusing to start NeDB to prevent dataloss&#x22;);
  }

  Object.keys(dataById).forEach(function (k) {
    tdata.push(dataById[k]);
  });

  return { data: tdata, indexes: indexes };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    function (cb) {
      Persistence.ensureDirectoryExists(path.dirname(self.filename), function (err) {
        storage.ensureDatafileIntegrity(self.filename, function (err) {
          storage.readFile(self.filename, &#x27;utf8&#x27;, function (err, rawData) {
if (err) { return cb(err); }

try {
  var treatedData = self.<span class="apidocCodeKeywordSpan">treatRawData</span>(rawData);
} catch (e) {
  return cb(e);
}

// Recreate all indexes in the datafile
Object.keys(treatedData.indexes).forEach(function (key) {
  self.db.indexes[key] = new Index(treatedData.indexes[key]);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nedb.storage" id="apidoc.module.nedb.storage">module nedb.storage</a></h1>


    <h2>
        <a href="#apidoc.element.nedb.storage.appendFile" id="apidoc.element.nedb.storage.appendFile">
        function <span class="apidocSignatureSpan">nedb.storage.</span>appendFile
        <span class="apidocSignatureSpan">(path, data, options, callback_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">appendFile = function (path, data, options, callback_) {
  var callback = maybeCallback(arguments[arguments.length - 1]);

  if (!options || typeof options === &#x27;function&#x27;) {
    options = { encoding: &#x27;utf8&#x27;, mode: 0o666, flag: &#x27;a&#x27; };
  } else if (typeof options === &#x27;string&#x27;) {
    options = { encoding: options, mode: 0o666, flag: &#x27;a&#x27; };
  } else if (typeof options !== &#x27;object&#x27;) {
    throwOptionsError(options);
  }

  if (!options.flag)
    options = util._extend({ flag: &#x27;a&#x27; }, options);

  // force append behavior when using a supplied file descriptor
  if (isFd(path))
    options.flag = &#x27;a&#x27;;

  fs.writeFile(path, data, options, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

 newDocs.forEach(function (doc) {
   toPersist += self.afterSerialization(model.serialize(doc)) + &#x27;\n&#x27;;
 });

 if (toPersist.length === 0) { return callback(null); }

 storage.<span class="apidocCodeKeywordSpan">appendFile</span>(self.filename, toPersist, &#x27;utf8&#x27;, function (err) {
   return callback(err);
 });
};


/**
* From a database&#x27;s raw data, return the corresponding
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.storage.crashSafeWriteFile" id="apidoc.element.nedb.storage.crashSafeWriteFile">
        function <span class="apidocSignatureSpan">nedb.storage.</span>crashSafeWriteFile
        <span class="apidocSignatureSpan">(filename, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">crashSafeWriteFile = function (filename, data, cb) {
  var callback = cb || function () {}
    , tempFilename = filename + &#x27;~&#x27;;

  async.waterfall([
    async.apply(storage.flushToStorage, { filename: path.dirname(filename), isDir: true })
  , function (cb) {
      storage.exists(filename, function (exists) {
        if (exists) {
          storage.flushToStorage(filename, function (err) { return cb(err); });
        } else {
          return cb();
        }
      });
    }
  , function (cb) {
      storage.writeFile(tempFilename, data, function (err) { return cb(err); });
    }
  , async.apply(storage.flushToStorage, tempFilename)
  , function (cb) {
      storage.rename(tempFilename, filename, function (err) { return cb(err); });
    }
  , async.apply(storage.flushToStorage, { filename: path.dirname(filename), isDir: true })
  ], function (err) { return callback(err); })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  });
  Object.keys(this.db.indexes).forEach(function (fieldName) {
    if (fieldName != &#x22;_id&#x22;) {   // The special _id index is managed by datastore.js, the others need to be persisted
      toPersist += self.afterSerialization(model.serialize({ $$indexCreated: { fieldName: fieldName, unique: self.db.indexes[fieldName
].unique, sparse: self.db.indexes[fieldName].sparse }})) + &#x27;\n&#x27;;
    }
  });

  storage.<span class="apidocCodeKeywordSpan">crashSafeWriteFile</span>(this.filename, toPersist, function (err) {
    if (err) { return callback(err); }
    self.db.emit(&#x27;compaction.done&#x27;);
    return callback(null);
  });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.storage.ensureDatafileIntegrity" id="apidoc.element.nedb.storage.ensureDatafileIntegrity">
        function <span class="apidocSignatureSpan">nedb.storage.</span>ensureDatafileIntegrity
        <span class="apidocSignatureSpan">(filename, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ensureDatafileIntegrity = function (filename, callback) {
  var tempFilename = filename + &#x27;~&#x27;;

  storage.exists(filename, function (filenameExists) {
    // Write was successful
    if (filenameExists) { return callback(null); }

    storage.exists(tempFilename, function (oldFilenameExists) {
      // New database
      if (!oldFilenameExists) {
        return storage.writeFile(filename, &#x27;&#x27;, &#x27;utf8&#x27;, function (err) { callback(err); });
      }

      // Write failed, use old version
      storage.rename(tempFilename, filename, function (err) { return callback(err); });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  // In-memory only datastore
  if (self.inMemoryOnly) { return callback(null); }

  async.waterfall([
    function (cb) {
      Persistence.ensureDirectoryExists(path.dirname(self.filename), function (err) {
        storage.<span class="apidocCodeKeywordSpan">ensureDatafileIntegrity</span>(self.filename, function (err) {
          storage.readFile(self.filename, &#x27;utf8&#x27;, function (err, rawData) {
if (err) { return cb(err); }

try {
  var treatedData = self.treatRawData(rawData);
} catch (e) {
  return cb(e);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.storage.ensureFileDoesntExist" id="apidoc.element.nedb.storage.ensureFileDoesntExist">
        function <span class="apidocSignatureSpan">nedb.storage.</span>ensureFileDoesntExist
        <span class="apidocSignatureSpan">(file, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ensureFileDoesntExist = function (file, callback) {
  storage.exists(file, function (exists) {
    if (!exists) { return callback(null); }

    storage.unlink(file, function (err) { return callback(err); });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  describe(&#x27;Serialization hooks&#x27;, function () {
    var as = function (s) { return &#x22;before_&#x22; + s + &#x22;_after&#x22;; }
      , bd = function (s) { return s.substring(7, s.length - 6); }

    it(&#x22;Declaring only one hook will throw an exception to prevent data loss&#x22;, function (done) {
      var hookTestFilename = &#x27;workspace/hookTest.db&#x27;
      storage.<span class="apidocCodeKeywordSpan">ensureFileDoesntExist</span>(hookTestFilename, function () {
fs.writeFileSync(hookTestFilename, &#x22;Some content&#x22;, &#x22;utf8&#x22;);

(function () {
  new Datastore({ filename: hookTestFilename, autoload: true
                , afterSerialization: as
  });
}).should.throw();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.storage.exists" id="apidoc.element.nedb.storage.exists">
        function <span class="apidocSignatureSpan">nedb.storage.</span>exists
        <span class="apidocSignatureSpan">(path, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exists = function (path, callback) {
  if (!nullCheck(path, cb)) return;
  var req = new FSReqWrap();
  req.oncomplete = cb;
  binding.stat(pathModule._makeLong(path), req);
  function cb(err, stats) {
    if (callback) callback(err ? false : true);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


/**
 * Ensure the workspace exists and the db datafile is empty
 */
module.exports.prepareDb = function (filename, cb) {
  Persistence.ensureDirectoryExists(path.dirname(filename), function () {
    fs.<span class="apidocCodeKeywordSpan">exists</span>(filename, function (exists) {
      if (exists) {
        fs.unlink(filename, cb);
      } else { return cb(); }
    });
  });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.storage.flushToStorage" id="apidoc.element.nedb.storage.flushToStorage">
        function <span class="apidocSignatureSpan">nedb.storage.</span>flushToStorage
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flushToStorage = function (options, callback) {
  var filename, flags;
  if (typeof options === &#x27;string&#x27;) {
    filename = options;
    flags = &#x27;r+&#x27;;
  } else {
    filename = options.filename;
    flags = options.isDir ? &#x27;r&#x27; : &#x27;r+&#x27;;
  }

  // Windows can&#x27;t fsync (FlushFileBuffers) directories. We can live with this as it cannot cause 100% dataloss
  // except in the very rare event of the first time database is loaded and a crash happens
  if (flags === &#x27;r&#x27; &#x26;&#x26; (process.platform === &#x27;win32&#x27; || process.platform === &#x27;win64&#x27;)) { return callback(null); }

  fs.open(filename, flags, function (err, fd) {
    if (err) { return callback(err); }
    fs.fsync(fd, function (errFS) {
      fs.close(fd, function (errC) {
        if (errFS || errC) {
          var e = new Error(&#x27;Failed to flush to storage&#x27;);
          e.errorOnFsync = errFS;
          e.errorOnClose = errC;
          return callback(e);
        } else {
          return callback(null);
        }
      });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  , tempFilename = filename + &#x27;~&#x27;;

async.waterfall([
  async.apply(storage.flushToStorage, { filename: path.dirname(filename), isDir: true })
, function (cb) {
    storage.exists(filename, function (exists) {
      if (exists) {
        storage.<span class="apidocCodeKeywordSpan">flushToStorage</span>(filename, function (err) { return cb(err); });
      } else {
        return cb();
      }
    });
  }
, function (cb) {
    storage.writeFile(tempFilename, data, function (err) { return cb(err); });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.storage.mkdirp" id="apidoc.element.nedb.storage.mkdirp">
        function <span class="apidocSignatureSpan">nedb.storage.</span>mkdirp
        <span class="apidocSignatureSpan">(p, opts, f, made)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mkdirP(p, opts, f, made) {
    if (typeof opts === &#x27;function&#x27;) {
        f = opts;
        opts = {};
    }
    else if (!opts || typeof opts !== &#x27;object&#x27;) {
        opts = { mode: opts };
    }

    var mode = opts.mode;
    var xfs = opts.fs || fs;

    if (mode === undefined) {
        mode = _0777 &#x26; (~process.umask());
    }
    if (!made) made = null;

    var cb = f || function () {};
    p = path.resolve(p);

    xfs.mkdir(p, mode, function (er) {
        if (!er) {
            made = made || p;
            return cb(null, made);
        }
        switch (er.code) {
            case &#x27;ENOENT&#x27;:
                mkdirP(path.dirname(p), opts, function (er, made) {
                    if (er) cb(er, made);
                    else mkdirP(p, opts, cb, made);
                });
                break;

            // In the case of any other error, just see if there&#x27;s a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
            default:
                xfs.stat(p, function (er2, stat) {
                    // if the stat fails, then that&#x27;s super weird.
                    // let the original error be the failure reason.
                    if (er2 || !stat.isDirectory()) cb(er, made)
                    else cb(null, made);
                });
                break;
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Check if a directory exists and create it on the fly if it is not the case
* cb is optional, signature: err
*/
Persistence.ensureDirectoryExists = function (dir, cb) {
 var callback = cb || function () {}
   ;

 storage.<span class="apidocCodeKeywordSpan">mkdirp</span>(dir, function (err) { return callback(err); });
};




/**
* Return the path the datafile if the given filename is relative to the directory where Node Webkit stores
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.storage.readFile" id="apidoc.element.nedb.storage.readFile">
        function <span class="apidocSignatureSpan">nedb.storage.</span>readFile
        <span class="apidocSignatureSpan">(path, options, callback_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readFile = function (path, options, callback_) {
  var callback = maybeCallback(arguments[arguments.length - 1]);

  if (!options || typeof options === &#x27;function&#x27;) {
    options = { encoding: null, flag: &#x27;r&#x27; };
  } else if (typeof options === &#x27;string&#x27;) {
    options = { encoding: options, flag: &#x27;r&#x27; };
  } else if (typeof options !== &#x27;object&#x27;) {
    throwOptionsError(options);
  }

  var encoding = options.encoding;
  assertEncoding(encoding);

  var flag = options.flag || &#x27;r&#x27;;

  if (!nullCheck(path, callback))
    return;

  var context = new ReadFileContext(callback, encoding);
  context.isUserFd = isFd(path); // file descriptor ownership
  var req = new FSReqWrap();
  req.context = context;
  req.oncomplete = readFileAfterOpen;

  if (context.isUserFd) {
    process.nextTick(function() {
      req.oncomplete(null, path);
    });
    return;
  }

  binding.open(pathModule._makeLong(path),
               stringToFlags(flag),
               0o666,
               req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // In-memory only datastore
  if (self.inMemoryOnly) { return callback(null); }

  async.waterfall([
    function (cb) {
      Persistence.ensureDirectoryExists(path.dirname(self.filename), function (err) {
        storage.ensureDatafileIntegrity(self.filename, function (err) {
          storage.<span class="apidocCodeKeywordSpan">readFile</span>(self.filename, &#x27;utf8&#x27;, function (err, rawData) {
if (err) { return cb(err); }

try {
  var treatedData = self.treatRawData(rawData);
} catch (e) {
  return cb(e);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.storage.rename" id="apidoc.element.nedb.storage.rename">
        function <span class="apidocSignatureSpan">nedb.storage.</span>rename
        <span class="apidocSignatureSpan">(oldPath, newPath, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rename = function (oldPath, newPath, callback) {
  callback = makeCallback(callback);
  if (!nullCheck(oldPath, callback)) return;
  if (!nullCheck(newPath, callback)) return;
  var req = new FSReqWrap();
  req.oncomplete = callback;
  binding.rename(pathModule._makeLong(oldPath),
                 pathModule._makeLong(newPath),
                 req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      });
    }
  , function (cb) {
      storage.writeFile(tempFilename, data, function (err) { return cb(err); });
    }
  , async.apply(storage.flushToStorage, tempFilename)
  , function (cb) {
      storage.<span class="apidocCodeKeywordSpan">rename</span>(tempFilename, filename, function (err) { return cb(err); });
    }
  , async.apply(storage.flushToStorage, { filename: path.dirname(filename), isDir: true })
  ], function (err) { return callback(err); })
};


/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.storage.unlink" id="apidoc.element.nedb.storage.unlink">
        function <span class="apidocSignatureSpan">nedb.storage.</span>unlink
        <span class="apidocSignatureSpan">(path, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unlink = function (path, callback) {
  callback = makeCallback(callback);
  if (!nullCheck(path, callback)) return;
  var req = new FSReqWrap();
  req.oncomplete = callback;
  binding.unlink(pathModule._makeLong(path), req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Ensure the workspace exists and the db datafile is empty
 */
module.exports.prepareDb = function (filename, cb) {
  Persistence.ensureDirectoryExists(path.dirname(filename), function () {
    fs.exists(filename, function (exists) {
      if (exists) {
        fs.<span class="apidocCodeKeywordSpan">unlink</span>(filename, cb);
      } else { return cb(); }
    });
  });
};


/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.storage.writeFile" id="apidoc.element.nedb.storage.writeFile">
        function <span class="apidocSignatureSpan">nedb.storage.</span>writeFile
        <span class="apidocSignatureSpan">(path, data, options, callback_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeFile = function (path, data, options, callback_) {
  var callback = maybeCallback(arguments[arguments.length - 1]);

  if (!options || typeof options === &#x27;function&#x27;) {
    options = { encoding: &#x27;utf8&#x27;, mode: 0o666, flag: &#x27;w&#x27; };
  } else if (typeof options === &#x27;string&#x27;) {
    options = { encoding: options, mode: 0o666, flag: &#x27;w&#x27; };
  } else if (typeof options !== &#x27;object&#x27;) {
    throwOptionsError(options);
  }

  assertEncoding(options.encoding);

  var flag = options.flag || &#x27;w&#x27;;

  if (isFd(path)) {
    writeFd(path, true);
    return;
  }

  fs.open(path, flag, options.mode, function(openErr, fd) {
    if (openErr) {
      callback(openErr);
    } else {
      writeFd(fd, false);
    }
  });

  function writeFd(fd, isUserFd) {
    var buffer = (data instanceof Buffer) ?
        data : Buffer.from(&#x27;&#x27; + data, options.encoding || &#x27;utf8&#x27;);
    var position = /a/.test(flag) ? null : 0;

    writeAll(fd, isUserFd, buffer, 0, buffer.length, position, callback);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var b = browserify()
  , srcPath = path.join(__dirname, &#x27;src/lib/datastore.js&#x27;);

b.add(srcPath);
b.bundle({ standalone: &#x27;Nedb&#x27; }, function (err, out) {
  if (err) { return cb(err); }
  fs.<span class="apidocCodeKeywordSpan">writeFile</span>(path.join(__dirname, &#x27;out/nedb.js&#x27;), out, &#x27;utf8&#x27;,
function (err) {
    if (err) {
      return cb(err);
    } else {
      return cb(null, out);
    }
  });
});
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
