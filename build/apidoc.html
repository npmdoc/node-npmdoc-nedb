<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/louischatriot/nedb"

    >nedb (v1.8.0)</a>
</h1>
<h4>File-based embedded data store for node.js</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.nedb">module nedb</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.cursor">
            function <span class="apidocSignatureSpan">nedb.</span>cursor
            <span class="apidocSignatureSpan">(db, query, execFn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.executor">
            function <span class="apidocSignatureSpan">nedb.</span>executor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.persistence">
            function <span class="apidocSignatureSpan">nedb.</span>persistence
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.super_">
            function <span class="apidocSignatureSpan">nedb.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">nedb.</span>commonUtilities</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">nedb.</span>cursor.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">nedb.</span>customUtils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">nedb.</span>executor.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">nedb.</span>model</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">nedb.</span>persistence.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">nedb.</span>storage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nedb.commonUtilities">module nedb.commonUtilities</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.commonUtilities.findDocs">
            function <span class="apidocSignatureSpan">nedb.commonUtilities.</span>findDocs
            <span class="apidocSignatureSpan">(d, n, profiler, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.commonUtilities.findDocsWithIn">
            function <span class="apidocSignatureSpan">nedb.commonUtilities.</span>findDocsWithIn
            <span class="apidocSignatureSpan">(d, n, profiler, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.commonUtilities.findOneDocs">
            function <span class="apidocSignatureSpan">nedb.commonUtilities.</span>findOneDocs
            <span class="apidocSignatureSpan">(d, n, profiler, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.commonUtilities.getConfiguration">
            function <span class="apidocSignatureSpan">nedb.commonUtilities.</span>getConfiguration
            <span class="apidocSignatureSpan">(benchDb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.commonUtilities.getRandomArray">
            function <span class="apidocSignatureSpan">nedb.commonUtilities.</span>getRandomArray
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.commonUtilities.insertDocs">
            function <span class="apidocSignatureSpan">nedb.commonUtilities.</span>insertDocs
            <span class="apidocSignatureSpan">(d, n, profiler, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.commonUtilities.loadDatabase">
            function <span class="apidocSignatureSpan">nedb.commonUtilities.</span>loadDatabase
            <span class="apidocSignatureSpan">(d, n, profiler, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.commonUtilities.prepareDb">
            function <span class="apidocSignatureSpan">nedb.commonUtilities.</span>prepareDb
            <span class="apidocSignatureSpan">(filename, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.commonUtilities.removeDocs">
            function <span class="apidocSignatureSpan">nedb.commonUtilities.</span>removeDocs
            <span class="apidocSignatureSpan">(options, d, n, profiler, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.commonUtilities.updateDocs">
            function <span class="apidocSignatureSpan">nedb.commonUtilities.</span>updateDocs
            <span class="apidocSignatureSpan">(options, d, n, profiler, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nedb.cursor">module nedb.cursor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.cursor.cursor">
            function <span class="apidocSignatureSpan">nedb.</span>cursor
            <span class="apidocSignatureSpan">(db, query, execFn)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nedb.cursor.prototype">module nedb.cursor.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.cursor.prototype._exec">
            function <span class="apidocSignatureSpan">nedb.cursor.prototype.</span>_exec
            <span class="apidocSignatureSpan">(_callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.cursor.prototype.exec">
            function <span class="apidocSignatureSpan">nedb.cursor.prototype.</span>exec
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.cursor.prototype.limit">
            function <span class="apidocSignatureSpan">nedb.cursor.prototype.</span>limit
            <span class="apidocSignatureSpan">(limit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.cursor.prototype.project">
            function <span class="apidocSignatureSpan">nedb.cursor.prototype.</span>project
            <span class="apidocSignatureSpan">(candidates)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.cursor.prototype.projection">
            function <span class="apidocSignatureSpan">nedb.cursor.prototype.</span>projection
            <span class="apidocSignatureSpan">(projection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.cursor.prototype.skip">
            function <span class="apidocSignatureSpan">nedb.cursor.prototype.</span>skip
            <span class="apidocSignatureSpan">(skip)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.cursor.prototype.sort">
            function <span class="apidocSignatureSpan">nedb.cursor.prototype.</span>sort
            <span class="apidocSignatureSpan">(sortQuery)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nedb.customUtils">module nedb.customUtils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.customUtils.uid">
            function <span class="apidocSignatureSpan">nedb.customUtils.</span>uid
            <span class="apidocSignatureSpan">(len)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nedb.executor">module nedb.executor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.executor.executor">
            function <span class="apidocSignatureSpan">nedb.</span>executor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nedb.executor.prototype">module nedb.executor.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.executor.prototype.processBuffer">
            function <span class="apidocSignatureSpan">nedb.executor.prototype.</span>processBuffer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.executor.prototype.push">
            function <span class="apidocSignatureSpan">nedb.executor.prototype.</span>push
            <span class="apidocSignatureSpan">(task, forceQueuing)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nedb.model">module nedb.model</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.model.areThingsEqual">
            function <span class="apidocSignatureSpan">nedb.model.</span>areThingsEqual
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.model.checkObject">
            function <span class="apidocSignatureSpan">nedb.model.</span>checkObject
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.model.compareThings">
            function <span class="apidocSignatureSpan">nedb.model.</span>compareThings
            <span class="apidocSignatureSpan">(a, b, _compareStrings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.model.deepCopy">
            function <span class="apidocSignatureSpan">nedb.model.</span>deepCopy
            <span class="apidocSignatureSpan">(obj, strictKeys)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.model.deserialize">
            function <span class="apidocSignatureSpan">nedb.model.</span>deserialize
            <span class="apidocSignatureSpan">(rawData)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.model.getDotValue">
            function <span class="apidocSignatureSpan">nedb.model.</span>getDotValue
            <span class="apidocSignatureSpan">(obj, field)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.model.isPrimitiveType">
            function <span class="apidocSignatureSpan">nedb.model.</span>isPrimitiveType
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.model.match">
            function <span class="apidocSignatureSpan">nedb.model.</span>match
            <span class="apidocSignatureSpan">(obj, query)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.model.modify">
            function <span class="apidocSignatureSpan">nedb.model.</span>modify
            <span class="apidocSignatureSpan">(obj, updateQuery)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.model.serialize">
            function <span class="apidocSignatureSpan">nedb.model.</span>serialize
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nedb.persistence">module nedb.persistence</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.persistence.persistence">
            function <span class="apidocSignatureSpan">nedb.</span>persistence
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.persistence.ensureDirectoryExists">
            function <span class="apidocSignatureSpan">nedb.persistence.</span>ensureDirectoryExists
            <span class="apidocSignatureSpan">(dir, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.persistence.getNWAppFilename">
            function <span class="apidocSignatureSpan">nedb.persistence.</span>getNWAppFilename
            <span class="apidocSignatureSpan">(appName, relativeFilename)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nedb.persistence.prototype">module nedb.persistence.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.persistence.prototype.compactDatafile">
            function <span class="apidocSignatureSpan">nedb.persistence.prototype.</span>compactDatafile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.persistence.prototype.loadDatabase">
            function <span class="apidocSignatureSpan">nedb.persistence.prototype.</span>loadDatabase
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.persistence.prototype.persistCachedDatabase">
            function <span class="apidocSignatureSpan">nedb.persistence.prototype.</span>persistCachedDatabase
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.persistence.prototype.persistNewState">
            function <span class="apidocSignatureSpan">nedb.persistence.prototype.</span>persistNewState
            <span class="apidocSignatureSpan">(newDocs, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.persistence.prototype.setAutocompactionInterval">
            function <span class="apidocSignatureSpan">nedb.persistence.prototype.</span>setAutocompactionInterval
            <span class="apidocSignatureSpan">(interval)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.persistence.prototype.stopAutocompaction">
            function <span class="apidocSignatureSpan">nedb.persistence.prototype.</span>stopAutocompaction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.persistence.prototype.treatRawData">
            function <span class="apidocSignatureSpan">nedb.persistence.prototype.</span>treatRawData
            <span class="apidocSignatureSpan">(rawData)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nedb.storage">module nedb.storage</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.storage.appendFile">
            function <span class="apidocSignatureSpan">nedb.storage.</span>appendFile
            <span class="apidocSignatureSpan">(path, data, options, callback_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.storage.crashSafeWriteFile">
            function <span class="apidocSignatureSpan">nedb.storage.</span>crashSafeWriteFile
            <span class="apidocSignatureSpan">(filename, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.storage.ensureDatafileIntegrity">
            function <span class="apidocSignatureSpan">nedb.storage.</span>ensureDatafileIntegrity
            <span class="apidocSignatureSpan">(filename, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.storage.ensureFileDoesntExist">
            function <span class="apidocSignatureSpan">nedb.storage.</span>ensureFileDoesntExist
            <span class="apidocSignatureSpan">(file, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.storage.exists">
            function <span class="apidocSignatureSpan">nedb.storage.</span>exists
            <span class="apidocSignatureSpan">(path, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.storage.flushToStorage">
            function <span class="apidocSignatureSpan">nedb.storage.</span>flushToStorage
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.storage.mkdirp">
            function <span class="apidocSignatureSpan">nedb.storage.</span>mkdirp
            <span class="apidocSignatureSpan">(p, opts, f, made)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.storage.readFile">
            function <span class="apidocSignatureSpan">nedb.storage.</span>readFile
            <span class="apidocSignatureSpan">(path, options, callback_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.storage.rename">
            function <span class="apidocSignatureSpan">nedb.storage.</span>rename
            <span class="apidocSignatureSpan">(oldPath, newPath, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.storage.unlink">
            function <span class="apidocSignatureSpan">nedb.storage.</span>unlink
            <span class="apidocSignatureSpan">(path, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nedb.storage.writeFile">
            function <span class="apidocSignatureSpan">nedb.storage.</span>writeFile
            <span class="apidocSignatureSpan">(path, data, options, callback_)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nedb" id="apidoc.module.nedb">module nedb</a></h1>


    <h2>
        <a href="#apidoc.element.nedb.cursor" id="apidoc.element.nedb.cursor">
        function <span class="apidocSignatureSpan">nedb.</span>cursor
        <span class="apidocSignatureSpan">(db, query, execFn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Cursor(db, query, execFn) {
  this.db = db;
  this.query = query || {};
  if (execFn) { this.execFn = execFn; }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.executor" id="apidoc.element.nedb.executor">
        function <span class="apidocSignatureSpan">nedb.</span>executor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Executor() {
  this.buffer = [];
  this.ready = false;

  // This queue will execute all commands, one-by-one in order
  this.queue = async.queue(function (task, cb) {
    var newArguments = [];

    // task.arguments is an array-like object on which adding a new field doesn&#x27;t work, so we transform it into a real array
    for (var i = 0; i &#x3c; task.arguments.length; i += 1) { newArguments.push(task.arguments[i]); }
    var lastArg = task.arguments[task.arguments.length - 1];

    // Always tell the queue task is complete. Execute callback if any was given.
    if (typeof lastArg === &#x27;function&#x27;) {
      // Callback was supplied
      newArguments[newArguments.length - 1] = function () {
        if (typeof setImmediate === &#x27;function&#x27;) {
           setImmediate(cb);
        } else {
          process.nextTick(cb);
        }
        lastArg.apply(null, arguments);
      };
    } else if (!lastArg &#x26;&#x26; task.arguments.length !== 0) {
      // false/undefined/null supplied as callbback
      newArguments[newArguments.length - 1] = function () { cb(); };
    } else {
      // Nothing supplied as callback
      newArguments.push(function () { cb(); });
    }


    task.fn.apply(task.this, newArguments);
  }, 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.persistence" id="apidoc.element.nedb.persistence">
        function <span class="apidocSignatureSpan">nedb.</span>persistence
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Persistence(options) {
  var i, j, randomString;

  this.db = options.db;
  this.inMemoryOnly = this.db.inMemoryOnly;
  this.filename = this.db.filename;
  this.corruptAlertThreshold = options.corruptAlertThreshold !== undefined ? options.corruptAlertThreshold : 0.1;

  if (!this.inMemoryOnly &#x26;&#x26; this.filename &#x26;&#x26; this.filename.charAt(this.filename.length - 1) === &#x27;~&#x27;) {
    throw new Error(&#x22;The datafile name can&#x27;t end with a ~, which is reserved for crash safe backup files&#x22;);
  }

  // After serialization and before deserialization hooks with some basic sanity checks
  if (options.afterSerialization &#x26;&#x26; !options.beforeDeserialization) {
    throw new Error(&#x22;Serialization hook defined but deserialization hook undefined, cautiously refusing to start NeDB to prevent
 dataloss&#x22;);
  }
  if (!options.afterSerialization &#x26;&#x26; options.beforeDeserialization) {
    throw new Error(&#x22;Serialization hook undefined but deserialization hook defined, cautiously refusing to start NeDB to prevent
 dataloss&#x22;);
  }
  this.afterSerialization = options.afterSerialization || function (s) { return s; };
  this.beforeDeserialization = options.beforeDeserialization || function (s) { return s; };
  for (i = 1; i &#x3c; 30; i += 1) {
    for (j = 0; j &#x3c; 10; j += 1) {
      randomString = customUtils.uid(i);
      if (this.beforeDeserialization(this.afterSerialization(randomString)) !== randomString) {
        throw new Error(&#x22;beforeDeserialization is not the reverse of afterSerialization, cautiously refusing to start NeDB to prevent
 dataloss&#x22;);
      }
    }
  }

  // For NW apps, store data in the same directory where NW stores application data
  if (this.filename &#x26;&#x26; options.nodeWebkitAppName) {
    console.log(&#x22;==================================================================&#x22;);
    console.log(&#x22;WARNING: The nodeWebkitAppName option is deprecated&#x22;);
    console.log(&#x22;To get the path to the directory where Node Webkit stores the data&#x22;);
    console.log(&#x22;for your app, use the internal nw.gui module like this&#x22;);
    console.log(&#x22;require(&#x27;nw.gui&#x27;).App.dataPath&#x22;);
    console.log(&#x22;See https://github.com/rogerwang/node-webkit/issues/500&#x22;);
    console.log(&#x22;==================================================================&#x22;);
    this.filename = Persistence.getNWAppFilename(options.nodeWebkitAppName, this.filename);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.super_" id="apidoc.element.nedb.super_">
        function <span class="apidocSignatureSpan">nedb.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nedb.commonUtilities" id="apidoc.module.nedb.commonUtilities">module nedb.commonUtilities</a></h1>


    <h2>
        <a href="#apidoc.element.nedb.commonUtilities.findDocs" id="apidoc.element.nedb.commonUtilities.findDocs">
        function <span class="apidocSignatureSpan">nedb.commonUtilities.</span>findDocs
        <span class="apidocSignatureSpan">(d, n, profiler, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findDocs = function (d, n, profiler, cb) {
  var beg = new Date()
    , order = getRandomArray(n)
    ;

  profiler.step(&#x22;Finding &#x22; + n + &#x22; documents&#x22;);

  function runFrom(i) {
    if (i === n) {   // Finished
      console.log(&#x22;===== RESULT (find) ===== &#x22; + Math.floor(1000* n / profiler.elapsedSinceLastStep()) + &#x22; ops/s&#x22;);
      profiler.step(&#x27;Finished finding &#x27; + n + &#x27; docs&#x27;);
      return cb();
    }

    d.find({ docNumber: order[i] }, function (err, docs) {
      if (docs.length !== 1 || docs[0].docNumber !== order[i]) { return cb(&#x27;One find didnt work&#x27;); }
      executeAsap(function () {
        runFrom(i + 1);
      });
    });
  }
  runFrom(0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.commonUtilities.findDocsWithIn" id="apidoc.element.nedb.commonUtilities.findDocsWithIn">
        function <span class="apidocSignatureSpan">nedb.commonUtilities.</span>findDocsWithIn
        <span class="apidocSignatureSpan">(d, n, profiler, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findDocsWithIn = function (d, n, profiler, cb) {
  var beg = new Date()
    , order = getRandomArray(n)
    , ins = [], i, j
    , arraySize = Math.min(10, n)   // The array for $in needs to be smaller than n (inclusive)
    ;

  // Preparing all the $in arrays, will take some time
  for (i = 0; i &#x3c; n; i += 1) {
    ins[i] = [];

    for (j = 0; j &#x3c; arraySize; j += 1) {
      ins[i].push((i + j) % n);
    }
  }

  profiler.step(&#x22;Finding &#x22; + n + &#x22; documents WITH $IN OPERATOR&#x22;);

  function runFrom(i) {
    if (i === n) {   // Finished
      console.log(&#x22;===== RESULT (find with in selector) ===== &#x22; + Math.floor(1000* n / profiler.elapsedSinceLastStep()) + &#x22; ops/
s&#x22;);
      profiler.step(&#x27;Finished finding &#x27; + n + &#x27; docs&#x27;);
      return cb();
    }

    d.find({ docNumber: { $in: ins[i] } }, function (err, docs) {
      if (docs.length !== arraySize) { return cb(&#x27;One find didnt work&#x27;); }
      executeAsap(function () {
        runFrom(i + 1);
      });
    });
  }
  runFrom(0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.commonUtilities.findOneDocs" id="apidoc.element.nedb.commonUtilities.findOneDocs">
        function <span class="apidocSignatureSpan">nedb.commonUtilities.</span>findOneDocs
        <span class="apidocSignatureSpan">(d, n, profiler, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findOneDocs = function (d, n, profiler, cb) {
  var beg = new Date()
    , order = getRandomArray(n)
    ;

  profiler.step(&#x22;FindingOne &#x22; + n + &#x22; documents&#x22;);

  function runFrom(i) {
    if (i === n) {   // Finished
      console.log(&#x22;===== RESULT (findOne) ===== &#x22; + Math.floor(1000* n / profiler.elapsedSinceLastStep()) + &#x22; ops/s&#x22;);
      profiler.step(&#x27;Finished finding &#x27; + n + &#x27; docs&#x27;);
      return cb();
    }

    d.findOne({ docNumber: order[i] }, function (err, doc) {
      if (!doc || doc.docNumber !== order[i]) { return cb(&#x27;One find didnt work&#x27;); }
      executeAsap(function () {
        runFrom(i + 1);
      });
    });
  }
  runFrom(0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.commonUtilities.getConfiguration" id="apidoc.element.nedb.commonUtilities.getConfiguration">
        function <span class="apidocSignatureSpan">nedb.commonUtilities.</span>getConfiguration
        <span class="apidocSignatureSpan">(benchDb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getConfiguration = function (benchDb) {
  var d, n
    , program = require(&#x27;commander&#x27;)
    ;

  program
    .option(&#x27;-n --number [number]&#x27;, &#x27;Size of the collection to test on&#x27;, parseInt)
    .option(&#x27;-i --with-index&#x27;, &#x27;Use an index&#x27;)
    .option(&#x27;-m --in-memory&#x27;, &#x27;Test with an in-memory only store&#x27;)
    .parse(process.argv);

  n = program.number || 10000;

  console.log(&#x22;----------------------------&#x22;);
  console.log(&#x22;Test with &#x22; + n + &#x22; documents&#x22;);
  console.log(program.withIndex ? &#x22;Use an index&#x22; : &#x22;Don&#x27;t use an index&#x22;);
  console.log(program.inMemory ? &#x22;Use an in-memory datastore&#x22; : &#x22;Use a persistent datastore&#x22;);
  console.log(&#x22;----------------------------&#x22;);

  d = new Datastore({ filename: benchDb
                    , inMemoryOnly: program.inMemory
                    });

  return { n: n, d: d, program: program };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.commonUtilities.getRandomArray" id="apidoc.element.nedb.commonUtilities.getRandomArray">
        function <span class="apidocSignatureSpan">nedb.commonUtilities.</span>getRandomArray
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getRandomArray(n) {
  var res = []
    , i, j, temp
    ;

  for (i = 0; i &#x3c; n; i += 1) { res[i] = i; }

  for (i = n - 1; i &#x3e;= 1; i -= 1) {
    j = Math.floor((i + 1) * Math.random());
    temp = res[i];
    res[i] = res[j];
    res[j] = temp;
  }

  return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.commonUtilities.insertDocs" id="apidoc.element.nedb.commonUtilities.insertDocs">
        function <span class="apidocSignatureSpan">nedb.commonUtilities.</span>insertDocs
        <span class="apidocSignatureSpan">(d, n, profiler, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insertDocs = function (d, n, profiler, cb) {
  var beg = new Date()
    , order = getRandomArray(n)
    ;

  profiler.step(&#x27;Begin inserting &#x27; + n + &#x27; docs&#x27;);

  function runFrom(i) {
    if (i === n) {   // Finished
      var opsPerSecond = Math.floor(1000* n / profiler.elapsedSinceLastStep());
      console.log(&#x22;===== RESULT (insert) ===== &#x22; + opsPerSecond + &#x22; ops/s&#x22;);
      profiler.step(&#x27;Finished inserting &#x27; + n + &#x27; docs&#x27;);
      profiler.insertOpsPerSecond = opsPerSecond;
      return cb();
    }

    d.insert({ docNumber: order[i] }, function (err) {
      executeAsap(function () {
        runFrom(i + 1);
      });
    });
  }
  runFrom(0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.commonUtilities.loadDatabase" id="apidoc.element.nedb.commonUtilities.loadDatabase">
        function <span class="apidocSignatureSpan">nedb.commonUtilities.</span>loadDatabase
        <span class="apidocSignatureSpan">(d, n, profiler, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadDatabase = function (d, n, profiler, cb) {
  var beg = new Date()
    , order = getRandomArray(n)
    ;

  profiler.step(&#x22;Loading the database &#x22; + n + &#x22; times&#x22;);

  function runFrom(i) {
    if (i === n) {   // Finished
      console.log(&#x22;===== RESULT ===== &#x22; + Math.floor(1000* n / profiler.elapsedSinceLastStep()) + &#x22; ops/s&#x22;);
      profiler.step(&#x27;Finished loading a database&#x27; + n + &#x27; times&#x27;);
      return cb();
    }

    d.loadDatabase(function (err) {
      executeAsap(function () {
        runFrom(i + 1);
      });
    });
  }
  runFrom(0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var Datastore = require(&#x27;nedb&#x27;)
, db = new Datastore();


// Type 2: Persistent datastore with manual loading
var Datastore = require(&#x27;nedb&#x27;)
, db = new Datastore({ filename: &#x27;path/to/datafile&#x27; });
db.<span class="apidocCodeKeywordSpan">loadDatabase</span>(function (err) {    // Callback is optional
// Now commands will be executed
});


// Type 3: Persistent datastore with automatic loading
var Datastore = require(&#x27;nedb&#x27;)
, db = new Datastore({ filename: &#x27;path/to/datafile&#x27;, autoload: true });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.commonUtilities.prepareDb" id="apidoc.element.nedb.commonUtilities.prepareDb">
        function <span class="apidocSignatureSpan">nedb.commonUtilities.</span>prepareDb
        <span class="apidocSignatureSpan">(filename, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prepareDb = function (filename, cb) {
  Persistence.ensureDirectoryExists(path.dirname(filename), function () {
    fs.exists(filename, function (exists) {
      if (exists) {
        fs.unlink(filename, cb);
      } else { return cb(); }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.commonUtilities.removeDocs" id="apidoc.element.nedb.commonUtilities.removeDocs">
        function <span class="apidocSignatureSpan">nedb.commonUtilities.</span>removeDocs
        <span class="apidocSignatureSpan">(options, d, n, profiler, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeDocs = function (options, d, n, profiler, cb) {
  var beg = new Date()
    , order = getRandomArray(n)
    ;

  profiler.step(&#x22;Removing &#x22; + n + &#x22; documents&#x22;);

  function runFrom(i) {
    if (i === n) {   // Finished
      // opsPerSecond corresponds to 1 insert + 1 remove, needed to keep collection size at 10,000
      // We need to subtract the time taken by one insert to get the time actually taken by one remove
      var opsPerSecond = Math.floor(1000 * n / profiler.elapsedSinceLastStep());
      var removeOpsPerSecond = Math.floor(1 / ((1 / opsPerSecond) - (1 / profiler.insertOpsPerSecond)))
      console.log(&#x22;===== RESULT (remove) ===== &#x22; + removeOpsPerSecond + &#x22; ops/s&#x22;);
      profiler.step(&#x27;Finished removing &#x27; + n + &#x27; docs&#x27;);
      return cb();
    }

    d.remove({ docNumber: order[i] }, options, function (err, nr) {
      if (err) { return cb(err); }
      if (nr !== 1) { return cb(&#x27;One remove didnt work&#x27;); }
      d.insert({ docNumber: order[i] }, function (err) {   // We need to reinsert the doc so that we keep the collection&#x27;s size
at n
                                                           // So actually we&#x27;re calculating the average time taken by one insert
 + one remove
        executeAsap(function () {
          runFrom(i + 1);
        });
      });
    });
  }
  runFrom(0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.commonUtilities.updateDocs" id="apidoc.element.nedb.commonUtilities.updateDocs">
        function <span class="apidocSignatureSpan">nedb.commonUtilities.</span>updateDocs
        <span class="apidocSignatureSpan">(options, d, n, profiler, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateDocs = function (options, d, n, profiler, cb) {
  var beg = new Date()
    , order = getRandomArray(n)
    ;

  profiler.step(&#x22;Updating &#x22; + n + &#x22; documents&#x22;);

  function runFrom(i) {
    if (i === n) {   // Finished
      console.log(&#x22;===== RESULT (update) ===== &#x22; + Math.floor(1000* n / profiler.elapsedSinceLastStep()) + &#x22; ops/s&#x22;);
      profiler.step(&#x27;Finished updating &#x27; + n + &#x27; docs&#x27;);
      return cb();
    }

    // Will not actually modify the document but will take the same time
    d.update({ docNumber: order[i] }, { docNumber: order[i] }, options, function (err, nr) {
      if (err) { return cb(err); }
      if (nr !== 1) { return cb(&#x27;One update didnt work&#x27;); }
      executeAsap(function () {
        runFrom(i + 1);
      });
    });
  }
  runFrom(0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nedb.cursor" id="apidoc.module.nedb.cursor">module nedb.cursor</a></h1>


    <h2>
        <a href="#apidoc.element.nedb.cursor.cursor" id="apidoc.element.nedb.cursor.cursor">
        function <span class="apidocSignatureSpan">nedb.</span>cursor
        <span class="apidocSignatureSpan">(db, query, execFn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Cursor(db, query, execFn) {
  this.db = db;
  this.query = query || {};
  if (execFn) { this.execFn = execFn; }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nedb.cursor.prototype" id="apidoc.module.nedb.cursor.prototype">module nedb.cursor.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.nedb.cursor.prototype._exec" id="apidoc.element.nedb.cursor.prototype._exec">
        function <span class="apidocSignatureSpan">nedb.cursor.prototype.</span>_exec
        <span class="apidocSignatureSpan">(_callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_exec = function (_callback) {
  var res = [], added = 0, skipped = 0, self = this
    , error = null
    , i, keys, key
    ;

  function callback (error, res) {
    if (self.execFn) {
      return self.execFn(error, res, _callback);
    } else {
      return _callback(error, res);
    }
  }

  this.db.getCandidates(this.query, function (err, candidates) {
    if (err) { return callback(err); }

    try {
      for (i = 0; i &#x3c; candidates.length; i += 1) {
        if (model.match(candidates[i], self.query)) {
          // If a sort is defined, wait for the results to be sorted before applying limit and skip
          if (!self._sort) {
            if (self._skip &#x26;&#x26; self._skip &#x3e; skipped) {
              skipped += 1;
            } else {
              res.push(candidates[i]);
              added += 1;
              if (self._limit &#x26;&#x26; self._limit &#x3c;= added) { break; }
            }
          } else {
            res.push(candidates[i]);
          }
        }
      }
    } catch (err) {
      return callback(err);
    }

    // Apply all sorts
    if (self._sort) {
      keys = Object.keys(self._sort);

      // Sorting
      var criteria = [];
      for (i = 0; i &#x3c; keys.length; i++) {
        key = keys[i];
        criteria.push({ key: key, direction: self._sort[key] });
      }
      res.sort(function(a, b) {
        var criterion, compare, i;
        for (i = 0; i &#x3c; criteria.length; i++) {
          criterion = criteria[i];
          compare = criterion.direction * model.compareThings(model.getDotValue(a, criterion.key), model.getDotValue(b, criterion
.key), self.db.compareStrings);
          if (compare !== 0) {
            return compare;
          }
        }
        return 0;
      });

      // Applying limit and skip
      var limit = self._limit || res.length
        , skip = self._skip || 0;

      res = res.slice(skip, skip + limit);
    }

    // Apply projection
    try {
      res = self.project(res);
    } catch (e) {
      error = e;
      res = undefined;
    }

    return callback(error, res);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.cursor.prototype.exec" id="apidoc.element.nedb.cursor.prototype.exec">
        function <span class="apidocSignatureSpan">nedb.cursor.prototype.</span>exec
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exec = function () {
  this.db.executor.push({ this: this, fn: this._exec, arguments: arguments });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Let&#x27;s say the database contains these 4 documents
// doc1 = { _id: &#x27;id1&#x27;, planet: &#x27;Mars&#x27;, system: &#x27;solar&#x27;, inhabited: false, satellites: [&#x27;Phobos
&#x27;, &#x27;Deimos&#x27;] }
// doc2 = { _id: &#x27;id2&#x27;, planet: &#x27;Earth&#x27;, system: &#x27;solar&#x27;, inhabited: true, humans: { genders: 2, eyes
: true } }
// doc3 = { _id: &#x27;id3&#x27;, planet: &#x27;Jupiter&#x27;, system: &#x27;solar&#x27;, inhabited: false }
// doc4 = { _id: &#x27;id4&#x27;, planet: &#x27;Omicron Persei 8&#x27;, system: &#x27;futurama&#x27;, inhabited: true, humans: {
genders: 7 } }

// No query used means all results are returned (before the Cursor modifiers)
db.find({}).sort({ planet: 1 }).skip(1).limit(2).<span class="apidocCodeKeywordSpan">exec</span>(function (err, docs) {
  // docs is [doc3, doc1]
});

// You can sort in reverse order like this
db.find({ system: &#x27;solar&#x27; }).sort({ planet: -1 }).exec(function (err, docs) {
  // docs is [doc1, doc3, doc2]
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.cursor.prototype.limit" id="apidoc.element.nedb.cursor.prototype.limit">
        function <span class="apidocSignatureSpan">nedb.cursor.prototype.</span>limit
        <span class="apidocSignatureSpan">(limit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">limit = function (limit) {
  this._limit = limit;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Let&#x27;s say the database contains these 4 documents
// doc1 = { _id: &#x27;id1&#x27;, planet: &#x27;Mars&#x27;, system: &#x27;solar&#x27;, inhabited: false, satellites: [&#x27;Phobos
&#x27;, &#x27;Deimos&#x27;] }
// doc2 = { _id: &#x27;id2&#x27;, planet: &#x27;Earth&#x27;, system: &#x27;solar&#x27;, inhabited: true, humans: { genders: 2, eyes
: true } }
// doc3 = { _id: &#x27;id3&#x27;, planet: &#x27;Jupiter&#x27;, system: &#x27;solar&#x27;, inhabited: false }
// doc4 = { _id: &#x27;id4&#x27;, planet: &#x27;Omicron Persei 8&#x27;, system: &#x27;futurama&#x27;, inhabited: true, humans: {
genders: 7 } }

// No query used means all results are returned (before the Cursor modifiers)
db.find({}).sort({ planet: 1 }).skip(1).<span class="apidocCodeKeywordSpan">limit</span>(2).exec(function (err, docs) {
  // docs is [doc3, doc1]
});

// You can sort in reverse order like this
db.find({ system: &#x27;solar&#x27; }).sort({ planet: -1 }).exec(function (err, docs) {
  // docs is [doc1, doc3, doc2]
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.cursor.prototype.project" id="apidoc.element.nedb.cursor.prototype.project">
        function <span class="apidocSignatureSpan">nedb.cursor.prototype.</span>project
        <span class="apidocSignatureSpan">(candidates)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">project = function (candidates) {
  var res = [], self = this
    , keepId, action, keys
    ;

  if (this._projection === undefined || Object.keys(this._projection).length === 0) {
    return candidates;
  }

  keepId = this._projection._id === 0 ? false : true;
  this._projection = _.omit(this._projection, &#x27;_id&#x27;);

  // Check for consistency
  keys = Object.keys(this._projection);
  keys.forEach(function (k) {
    if (action !== undefined &#x26;&#x26; self._projection[k] !== action) { throw new Error(&#x22;Can&#x27;t both keep and omit fields except for _id
&#x22;); }
    action = self._projection[k];
  });

  // Do the actual projection
  candidates.forEach(function (candidate) {
    var toPush;
    if (action === 1) {   // pick-type projection
      toPush = { $set: {} };
      keys.forEach(function (k) {
        toPush.$set[k] = model.getDotValue(candidate, k);
        if (toPush.$set[k] === undefined) { delete toPush.$set[k]; }
      });
      toPush = model.modify({}, toPush);
    } else {   // omit-type projection
      toPush = { $unset: {} };
      keys.forEach(function (k) { toPush.$unset[k] = true });
      toPush = model.modify(candidate, toPush);
    }
    if (keepId) {
      toPush._id = candidate._id;
    } else {
      delete toPush._id;
    }
    res.push(toPush);
  });

  return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      , skip = self._skip || 0;

    res = res.slice(skip, skip + limit);
  }

  // Apply projection
  try {
    res = self.<span class="apidocCodeKeywordSpan">project</span>(res);
  } catch (e) {
    error = e;
    res = undefined;
  }

  return callback(error, res);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.cursor.prototype.projection" id="apidoc.element.nedb.cursor.prototype.projection">
        function <span class="apidocSignatureSpan">nedb.cursor.prototype.</span>projection
        <span class="apidocSignatureSpan">(projection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">projection = function (projection) {
  this._projection = projection;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Failure: using both modes at the same time
db.find({ planet: &#x27;Mars&#x27; }, { planet: 0, system: 1 }, function (err, docs) {
  // err is the error message, docs is undefined
});

// You can also use it in a Cursor way but this syntax is not compatible with MongoDB
db.find({ planet: &#x27;Mars&#x27; }).<span class="apidocCodeKeywordSpan">projection</span>({ planet: 1, system: 1 }).exec(function
 (err, docs) {
  // docs is [{ planet: &#x27;Mars&#x27;, system: &#x27;solar&#x27;, _id: &#x27;id1&#x27; }]
});

// Project on a nested document
db.findOne({ planet: &#x27;Earth&#x27; }).projection({ planet: 1, &#x27;humans.genders&#x27;: 1 }).exec(function (err, doc) {
  // doc is { planet: &#x27;Earth&#x27;, _id: &#x27;id2&#x27;, humans: { genders: 2 } }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.cursor.prototype.skip" id="apidoc.element.nedb.cursor.prototype.skip">
        function <span class="apidocSignatureSpan">nedb.cursor.prototype.</span>skip
        <span class="apidocSignatureSpan">(skip)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skip = function (skip) {
  this._skip = skip;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Let&#x27;s say the database contains these 4 documents
// doc1 = { _id: &#x27;id1&#x27;, planet: &#x27;Mars&#x27;, system: &#x27;solar&#x27;, inhabited: false, satellites: [&#x27;Phobos
&#x27;, &#x27;Deimos&#x27;] }
// doc2 = { _id: &#x27;id2&#x27;, planet: &#x27;Earth&#x27;, system: &#x27;solar&#x27;, inhabited: true, humans: { genders: 2, eyes
: true } }
// doc3 = { _id: &#x27;id3&#x27;, planet: &#x27;Jupiter&#x27;, system: &#x27;solar&#x27;, inhabited: false }
// doc4 = { _id: &#x27;id4&#x27;, planet: &#x27;Omicron Persei 8&#x27;, system: &#x27;futurama&#x27;, inhabited: true, humans: {
genders: 7 } }

// No query used means all results are returned (before the Cursor modifiers)
db.find({}).sort({ planet: 1 }).<span class="apidocCodeKeywordSpan">skip</span>(1).limit(2).exec(function (err, docs) {
  // docs is [doc3, doc1]
});

// You can sort in reverse order like this
db.find({ system: &#x27;solar&#x27; }).sort({ planet: -1 }).exec(function (err, docs) {
  // docs is [doc1, doc3, doc2]
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.cursor.prototype.sort" id="apidoc.element.nedb.cursor.prototype.sort">
        function <span class="apidocSignatureSpan">nedb.cursor.prototype.</span>sort
        <span class="apidocSignatureSpan">(sortQuery)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sort = function (sortQuery) {
  this._sort = sortQuery;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Let&#x27;s say the database contains these 4 documents
// doc1 = { _id: &#x27;id1&#x27;, planet: &#x27;Mars&#x27;, system: &#x27;solar&#x27;, inhabited: false, satellites: [&#x27;Phobos
&#x27;, &#x27;Deimos&#x27;] }
// doc2 = { _id: &#x27;id2&#x27;, planet: &#x27;Earth&#x27;, system: &#x27;solar&#x27;, inhabited: true, humans: { genders: 2, eyes
: true } }
// doc3 = { _id: &#x27;id3&#x27;, planet: &#x27;Jupiter&#x27;, system: &#x27;solar&#x27;, inhabited: false }
// doc4 = { _id: &#x27;id4&#x27;, planet: &#x27;Omicron Persei 8&#x27;, system: &#x27;futurama&#x27;, inhabited: true, humans: {
genders: 7 } }

// No query used means all results are returned (before the Cursor modifiers)
db.find({}).<span class="apidocCodeKeywordSpan">sort</span>({ planet: 1 }).skip(1).limit(2).exec(function (err, docs) {
  // docs is [doc3, doc1]
});

// You can sort in reverse order like this
db.find({ system: &#x27;solar&#x27; }).sort({ planet: -1 }).exec(function (err, docs) {
  // docs is [doc1, doc3, doc2]
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nedb.customUtils" id="apidoc.module.nedb.customUtils">module nedb.customUtils</a></h1>


    <h2>
        <a href="#apidoc.element.nedb.customUtils.uid" id="apidoc.element.nedb.customUtils.uid">
        function <span class="apidocSignatureSpan">nedb.customUtils.</span>uid
        <span class="apidocSignatureSpan">(len)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function uid(len) {
  return crypto.randomBytes(Math.ceil(Math.max(8, len * 2)))
    .toString(&#x27;base64&#x27;)
    .replace(/[+\/]/g, &#x27;&#x27;)
    .slice(0, len);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!options.afterSerialization &#x26;&#x26; options.beforeDeserialization) {
  throw new Error(&#x22;Serialization hook undefined but deserialization hook defined, cautiously refusing to start NeDB to prevent
 dataloss&#x22;);
}
this.afterSerialization = options.afterSerialization || function (s) { return s; };
this.beforeDeserialization = options.beforeDeserialization || function (s) { return s; };
for (i = 1; i &#x3c; 30; i += 1) {
  for (j = 0; j &#x3c; 10; j += 1) {
    randomString = customUtils.<span class="apidocCodeKeywordSpan">uid</span>(i);
    if (this.beforeDeserialization(this.afterSerialization(randomString)) !== randomString) {
      throw new Error(&#x22;beforeDeserialization is not the reverse of afterSerialization, cautiously refusing to start NeDB to
 prevent dataloss&#x22;);
    }
  }
}

// For NW apps, store data in the same directory where NW stores application data
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nedb.executor" id="apidoc.module.nedb.executor">module nedb.executor</a></h1>


    <h2>
        <a href="#apidoc.element.nedb.executor.executor" id="apidoc.element.nedb.executor.executor">
        function <span class="apidocSignatureSpan">nedb.</span>executor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Executor() {
  this.buffer = [];
  this.ready = false;

  // This queue will execute all commands, one-by-one in order
  this.queue = async.queue(function (task, cb) {
    var newArguments = [];

    // task.arguments is an array-like object on which adding a new field doesn&#x27;t work, so we transform it into a real array
    for (var i = 0; i &#x3c; task.arguments.length; i += 1) { newArguments.push(task.arguments[i]); }
    var lastArg = task.arguments[task.arguments.length - 1];

    // Always tell the queue task is complete. Execute callback if any was given.
    if (typeof lastArg === &#x27;function&#x27;) {
      // Callback was supplied
      newArguments[newArguments.length - 1] = function () {
        if (typeof setImmediate === &#x27;function&#x27;) {
           setImmediate(cb);
        } else {
          process.nextTick(cb);
        }
        lastArg.apply(null, arguments);
      };
    } else if (!lastArg &#x26;&#x26; task.arguments.length !== 0) {
      // false/undefined/null supplied as callbback
      newArguments[newArguments.length - 1] = function () { cb(); };
    } else {
      // Nothing supplied as callback
      newArguments.push(function () { cb(); });
    }


    task.fn.apply(task.this, newArguments);
  }, 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nedb.executor.prototype" id="apidoc.module.nedb.executor.prototype">module nedb.executor.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.nedb.executor.prototype.processBuffer" id="apidoc.element.nedb.executor.prototype.processBuffer">
        function <span class="apidocSignatureSpan">nedb.executor.prototype.</span>processBuffer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processBuffer = function () {
  var i;
  this.ready = true;
  for (i = 0; i &#x3c; this.buffer.length; i += 1) { this.queue.push(this.buffer[i]); }
  this.buffer = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          });
        });
      });
    }
  ], function (err) {
       if (err) { return callback(err); }

       self.db.executor.<span class="apidocCodeKeywordSpan">processBuffer</span>();
       return callback(null);
     });
};


// Interface
module.exports = Persistence;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.executor.prototype.push" id="apidoc.element.nedb.executor.prototype.push">
        function <span class="apidocSignatureSpan">nedb.executor.prototype.</span>push
        <span class="apidocSignatureSpan">(task, forceQueuing)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function (task, forceQueuing) {
  if (this.ready || forceQueuing) {
    this.queue.push(task);
  } else {
    this.buffer.push(task);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ;

// Preparing all the $in arrays, will take some time
for (i = 0; i &#x3c; n; i += 1) {
  ins[i] = [];

  for (j = 0; j &#x3c; arraySize; j += 1) {
    ins[i].<span class="apidocCodeKeywordSpan">push</span>((i + j) % n);
  }
}

profiler.step(&#x22;Finding &#x22; + n + &#x22; documents WITH $IN OPERATOR&#x22;);

function runFrom(i) {
  if (i === n) {   // Finished
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nedb.model" id="apidoc.module.nedb.model">module nedb.model</a></h1>


    <h2>
        <a href="#apidoc.element.nedb.model.areThingsEqual" id="apidoc.element.nedb.model.areThingsEqual">
        function <span class="apidocSignatureSpan">nedb.model.</span>areThingsEqual
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function areThingsEqual(a, b) {
  var aKeys , bKeys , i;

  // Strings, booleans, numbers, null
  if (a === null || typeof a === &#x27;string&#x27; || typeof a === &#x27;boolean&#x27; || typeof a === &#x27;number&#x27; ||
      b === null || typeof b === &#x27;string&#x27; || typeof b === &#x27;boolean&#x27; || typeof b === &#x27;number&#x27;) { return a === b; }

  // Dates
  if (util.isDate(a) || util.isDate(b)) { return util.isDate(a) &#x26;&#x26; util.isDate(b) &#x26;&#x26; a.getTime() === b.getTime(); }

  // Arrays (no match since arrays are used as a $in)
  // undefined (no match since they mean field doesn&#x27;t exist and can&#x27;t be serialized)
  if ((!(util.isArray(a) &#x26;&#x26; util.isArray(b)) &#x26;&#x26; (util.isArray(a) || util.isArray(b))) || a === undefined || b === undefined) { return
 false; }

  // General objects (check for deep equality)
  // a and b should be objects at this point
  try {
    aKeys = Object.keys(a);
    bKeys = Object.keys(b);
  } catch (e) {
    return false;
  }

  if (aKeys.length !== bKeys.length) { return false; }
  for (i = 0; i &#x3c; aKeys.length; i += 1) {
    if (bKeys.indexOf(aKeys[i]) === -1) { return false; }
    if (!areThingsEqual(a[aKeys[i]], b[aKeys[i]])) { return false; }
  }
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.model.checkObject" id="apidoc.element.nedb.model.checkObject">
        function <span class="apidocSignatureSpan">nedb.model.</span>checkObject
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkObject(obj) {
  if (util.isArray(obj)) {
    obj.forEach(function (o) {
      checkObject(o);
    });
  }

  if (typeof obj === &#x27;object&#x27; &#x26;&#x26; obj !== null) {
    Object.keys(obj).forEach(function (k) {
      checkKey(k, obj[k]);
      checkObject(obj[k]);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.model.compareThings" id="apidoc.element.nedb.model.compareThings">
        function <span class="apidocSignatureSpan">nedb.model.</span>compareThings
        <span class="apidocSignatureSpan">(a, b, _compareStrings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compareThings(a, b, _compareStrings) {
  var aKeys, bKeys, comp, i
    , compareStrings = _compareStrings || compareNSB;

  // undefined
  if (a === undefined) { return b === undefined ? 0 : -1; }
  if (b === undefined) { return a === undefined ? 0 : 1; }

  // null
  if (a === null) { return b === null ? 0 : -1; }
  if (b === null) { return a === null ? 0 : 1; }

  // Numbers
  if (typeof a === &#x27;number&#x27;) { return typeof b === &#x27;number&#x27; ? compareNSB(a, b) : -1; }
  if (typeof b === &#x27;number&#x27;) { return typeof a === &#x27;number&#x27; ? compareNSB(a, b) : 1; }

  // Strings
  if (typeof a === &#x27;string&#x27;) { return typeof b === &#x27;string&#x27; ? compareStrings(a, b) : -1; }
  if (typeof b === &#x27;string&#x27;) { return typeof a === &#x27;string&#x27; ? compareStrings(a, b) : 1; }

  // Booleans
  if (typeof a === &#x27;boolean&#x27;) { return typeof b === &#x27;boolean&#x27; ? compareNSB(a, b) : -1; }
  if (typeof b === &#x27;boolean&#x27;) { return typeof a === &#x27;boolean&#x27; ? compareNSB(a, b) : 1; }

  // Dates
  if (util.isDate(a)) { return util.isDate(b) ? compareNSB(a.getTime(), b.getTime()) : -1; }
  if (util.isDate(b)) { return util.isDate(a) ? compareNSB(a.getTime(), b.getTime()) : 1; }

  // Arrays (first element is most significant and so on)
  if (util.isArray(a)) { return util.isArray(b) ? compareArrays(a, b) : -1; }
  if (util.isArray(b)) { return util.isArray(a) ? compareArrays(a, b) : 1; }

  // Objects
  aKeys = Object.keys(a).sort();
  bKeys = Object.keys(b).sort();

  for (i = 0; i &#x3c; Math.min(aKeys.length, bKeys.length); i += 1) {
    comp = compareThings(a[aKeys[i]], b[bKeys[i]]);

    if (comp !== 0) { return comp; }
  }

  return compareNSB(aKeys.length, bKeys.length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  key = keys[i];
  criteria.push({ key: key, direction: self._sort[key] });
}
res.sort(function(a, b) {
  var criterion, compare, i;
  for (i = 0; i &#x3c; criteria.length; i++) {
    criterion = criteria[i];
    compare = criterion.direction * model.<span class="apidocCodeKeywordSpan">compareThings</span>(model.getDotValue(a, criterion
.key), model.getDotValue(b, criterion.key), self.db.compareStrings);
    if (compare !== 0) {
      return compare;
    }
  }
  return 0;
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.model.deepCopy" id="apidoc.element.nedb.model.deepCopy">
        function <span class="apidocSignatureSpan">nedb.model.</span>deepCopy
        <span class="apidocSignatureSpan">(obj, strictKeys)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deepCopy(obj, strictKeys) {
  var res;

  if ( typeof obj === &#x27;boolean&#x27; ||
       typeof obj === &#x27;number&#x27; ||
       typeof obj === &#x27;string&#x27; ||
       obj === null ||
       (util.isDate(obj)) ) {
    return obj;
  }

  if (util.isArray(obj)) {
    res = [];
    obj.forEach(function (o) { res.push(deepCopy(o, strictKeys)); });
    return res;
  }

  if (typeof obj === &#x27;object&#x27;) {
    res = {};
    Object.keys(obj).forEach(function (k) {
      if (!strictKeys || (k[0] !== &#x27;$&#x27; &#x26;&#x26; k.indexOf(&#x27;.&#x27;) === -1)) {
        res[k] = deepCopy(obj[k], strictKeys);
      }
    });
    return res;
  }

  return undefined;   // For now everything else is undefined. We should probably throw an error instead
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.model.deserialize" id="apidoc.element.nedb.model.deserialize">
        function <span class="apidocSignatureSpan">nedb.model.</span>deserialize
        <span class="apidocSignatureSpan">(rawData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deserialize(rawData) {
  return JSON.parse(rawData, function (k, v) {
    if (k === &#x27;$$date&#x27;) { return new Date(v); }
    if (typeof v === &#x27;string&#x27; || typeof v === &#x27;number&#x27; || typeof v === &#x27;boolean&#x27; || v === null) { return v; }
    if (v &#x26;&#x26; v.$$date) { return v.$$date; }

    return v;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
, corruptItems = -1   // Last line of every data file is usually blank so not really corrupt
;

  for (i = 0; i &#x3c; data.length; i += 1) {
var doc;

try {
  doc = model.<span class="apidocCodeKeywordSpan">deserialize</span>(this.beforeDeserialization(data[i]));
  if (doc._id) {
    if (doc.$$deleted === true) {
      delete dataById[doc._id];
    } else {
      dataById[doc._id] = doc;
    }
  } else if (doc.$$indexCreated &#x26;&#x26; doc.$$indexCreated.fieldName != undefined) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.model.getDotValue" id="apidoc.element.nedb.model.getDotValue">
        function <span class="apidocSignatureSpan">nedb.model.</span>getDotValue
        <span class="apidocSignatureSpan">(obj, field)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDotValue(obj, field) {
  var fieldParts = typeof field === &#x27;string&#x27; ? field.split(&#x27;.&#x27;) : field
    , i, objs;

  if (!obj) { return undefined; }   // field cannot be empty so that means we should return undefined so that nothing can match

  if (fieldParts.length === 0) { return obj; }

  if (fieldParts.length === 1) { return obj[fieldParts[0]]; }

  if (util.isArray(obj[fieldParts[0]])) {
    // If the next field is an integer, return only this item of the array
    i = parseInt(fieldParts[1], 10);
    if (typeof i === &#x27;number&#x27; &#x26;&#x26; !isNaN(i)) {
      return getDotValue(obj[fieldParts[0]][i], fieldParts.slice(2))
    }

    // Return the array of values
    objs = new Array();
    for (i = 0; i &#x3c; obj[fieldParts[0]].length; i += 1) {
       objs.push(getDotValue(obj[fieldParts[0]][i], fieldParts.slice(1)));
    }
    return objs;
  } else {
    return getDotValue(obj[fieldParts[0]], fieldParts.slice(1));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Do the actual projection
candidates.forEach(function (candidate) {
  var toPush;
  if (action === 1) {   // pick-type projection
    toPush = { $set: {} };
    keys.forEach(function (k) {
      toPush.$set[k] = model.<span class="apidocCodeKeywordSpan">getDotValue</span>(candidate, k);
      if (toPush.$set[k] === undefined) { delete toPush.$set[k]; }
    });
    toPush = model.modify({}, toPush);
  } else {   // omit-type projection
    toPush = { $unset: {} };
    keys.forEach(function (k) { toPush.$unset[k] = true });
    toPush = model.modify(candidate, toPush);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.model.isPrimitiveType" id="apidoc.element.nedb.model.isPrimitiveType">
        function <span class="apidocSignatureSpan">nedb.model.</span>isPrimitiveType
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isPrimitiveType(obj) {
  return ( typeof obj === &#x27;boolean&#x27; ||
       typeof obj === &#x27;number&#x27; ||
       typeof obj === &#x27;string&#x27; ||
       obj === null ||
       util.isDate(obj) ||
       util.isArray(obj));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.model.match" id="apidoc.element.nedb.model.match">
        function <span class="apidocSignatureSpan">nedb.model.</span>match
        <span class="apidocSignatureSpan">(obj, query)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function match(obj, query) {
  var queryKeys, queryKey, queryValue, i;

  // Primitive query against a primitive type
  // This is a bit of a hack since we construct an object with an arbitrary key only to dereference it later
  // But I don&#x27;t have time for a cleaner implementation now
  if (isPrimitiveType(obj) || isPrimitiveType(query)) {
    return matchQueryPart({ needAKey: obj }, &#x27;needAKey&#x27;, query);
  }

  // Normal query
  queryKeys = Object.keys(query);
  for (i = 0; i &#x3c; queryKeys.length; i += 1) {
    queryKey = queryKeys[i];
    queryValue = query[queryKey];

    if (queryKey[0] === &#x27;$&#x27;) {
      if (!logicalOperators[queryKey]) { throw new Error(&#x22;Unknown logical operator &#x22; + queryKey); }
      if (!logicalOperators[queryKey](obj, queryValue)) { return false; }
    } else {
      if (!matchQueryPart(obj, queryKey, queryValue)) { return false; }
    }
  }

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  this.db.getCandidates(this.query, function (err, candidates) {
if (err) { return callback(err); }

try {
  for (i = 0; i &#x3c; candidates.length; i += 1) {
    if (model.<span class="apidocCodeKeywordSpan">match</span>(candidates[i], self.query)) {
      // If a sort is defined, wait for the results to be sorted before applying limit and skip
      if (!self._sort) {
        if (self._skip &#x26;&#x26; self._skip &#x3e; skipped) {
          skipped += 1;
        } else {
          res.push(candidates[i]);
          added += 1;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.model.modify" id="apidoc.element.nedb.model.modify">
        function <span class="apidocSignatureSpan">nedb.model.</span>modify
        <span class="apidocSignatureSpan">(obj, updateQuery)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function modify(obj, updateQuery) {
  var keys = Object.keys(updateQuery)
    , firstChars = _.map(keys, function (item) { return item[0]; })
    , dollarFirstChars = _.filter(firstChars, function (c) { return c === &#x27;$&#x27;; })
    , newDoc, modifiers
    ;

  if (keys.indexOf(&#x27;_id&#x27;) !== -1 &#x26;&#x26; updateQuery._id !== obj._id) { throw new Error(&#x22;You cannot change a document&#x27;s _id&#x22;); }

  if (dollarFirstChars.length !== 0 &#x26;&#x26; dollarFirstChars.length !== firstChars.length) {
    throw new Error(&#x22;You cannot mix modifiers and normal fields&#x22;);
  }

  if (dollarFirstChars.length === 0) {
    // Simply replace the object with the update query contents
    newDoc = deepCopy(updateQuery);
    newDoc._id = obj._id;
  } else {
    // Apply modifiers
    modifiers = _.uniq(keys);
    newDoc = deepCopy(obj);
    modifiers.forEach(function (m) {
      var keys;

      if (!modifierFunctions[m]) { throw new Error(&#x22;Unknown modifier &#x22; + m); }

      // Can&#x27;t rely on Object.keys throwing on non objects since ES6
      // Not 100% satisfying as non objects can be interpreted as objects but no false negatives so we can live with it
      if (typeof updateQuery[m] !== &#x27;object&#x27;) {
        throw new Error(&#x22;Modifier &#x22; + m + &#x22;&#x27;s argument must be an object&#x22;);
      }

      keys = Object.keys(updateQuery[m]);
      keys.forEach(function (k) {
        modifierFunctions[m](newDoc, k, updateQuery[m][k]);
      });
    });
  }

  // Check result is valid and return it
  checkObject(newDoc);

  if (obj._id !== newDoc._id) { throw new Error(&#x22;You can&#x27;t change a document&#x27;s _id&#x22;); }
  return newDoc;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var toPush;
if (action === 1) {   // pick-type projection
  toPush = { $set: {} };
  keys.forEach(function (k) {
    toPush.$set[k] = model.getDotValue(candidate, k);
    if (toPush.$set[k] === undefined) { delete toPush.$set[k]; }
  });
  toPush = model.<span class="apidocCodeKeywordSpan">modify</span>({}, toPush);
} else {   // omit-type projection
  toPush = { $unset: {} };
  keys.forEach(function (k) { toPush.$unset[k] = true });
  toPush = model.modify(candidate, toPush);
}
if (keepId) {
  toPush._id = candidate._id;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.model.serialize" id="apidoc.element.nedb.model.serialize">
        function <span class="apidocSignatureSpan">nedb.model.</span>serialize
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function serialize(obj) {
  var res;

  res = JSON.stringify(obj, function (k, v) {
    checkKey(k, v);

    if (v === undefined) { return undefined; }
    if (v === null) { return null; }

    // Hackish way of checking if object is Date (this way it works between execution contexts in node-webkit).
    // We can&#x27;t use value directly because for dates it is already string in this function (date.toJSON was already called), so
we use this
    if (typeof this[k].getTime === &#x27;function&#x27;) { return { $$date: this[k].getTime() }; }

    return v;
  });

  return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  , toPersist = &#x27;&#x27;
  , self = this
  ;

if (this.inMemoryOnly) { return callback(null); }

this.db.getAllData().forEach(function (doc) {
  toPersist += self.afterSerialization(model.<span class="apidocCodeKeywordSpan">serialize</span>(doc)) + &#x27;\n&#x27;;
});
Object.keys(this.db.indexes).forEach(function (fieldName) {
  if (fieldName != &#x22;_id&#x22;) {   // The special _id index is managed by datastore.js, the others need to be persisted
    toPersist += self.afterSerialization(model.serialize({ $$indexCreated: { fieldName: fieldName, unique: self.db.indexes[fieldName
].unique, sparse: self.db.indexes[fieldName].sparse }})) + &#x27;\n&#x27;;
  }
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nedb.persistence" id="apidoc.module.nedb.persistence">module nedb.persistence</a></h1>


    <h2>
        <a href="#apidoc.element.nedb.persistence.persistence" id="apidoc.element.nedb.persistence.persistence">
        function <span class="apidocSignatureSpan">nedb.</span>persistence
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Persistence(options) {
  var i, j, randomString;

  this.db = options.db;
  this.inMemoryOnly = this.db.inMemoryOnly;
  this.filename = this.db.filename;
  this.corruptAlertThreshold = options.corruptAlertThreshold !== undefined ? options.corruptAlertThreshold : 0.1;

  if (!this.inMemoryOnly &#x26;&#x26; this.filename &#x26;&#x26; this.filename.charAt(this.filename.length - 1) === &#x27;~&#x27;) {
    throw new Error(&#x22;The datafile name can&#x27;t end with a ~, which is reserved for crash safe backup files&#x22;);
  }

  // After serialization and before deserialization hooks with some basic sanity checks
  if (options.afterSerialization &#x26;&#x26; !options.beforeDeserialization) {
    throw new Error(&#x22;Serialization hook defined but deserialization hook undefined, cautiously refusing to start NeDB to prevent
 dataloss&#x22;);
  }
  if (!options.afterSerialization &#x26;&#x26; options.beforeDeserialization) {
    throw new Error(&#x22;Serialization hook undefined but deserialization hook defined, cautiously refusing to start NeDB to prevent
 dataloss&#x22;);
  }
  this.afterSerialization = options.afterSerialization || function (s) { return s; };
  this.beforeDeserialization = options.beforeDeserialization || function (s) { return s; };
  for (i = 1; i &#x3c; 30; i += 1) {
    for (j = 0; j &#x3c; 10; j += 1) {
      randomString = customUtils.uid(i);
      if (this.beforeDeserialization(this.afterSerialization(randomString)) !== randomString) {
        throw new Error(&#x22;beforeDeserialization is not the reverse of afterSerialization, cautiously refusing to start NeDB to prevent
 dataloss&#x22;);
      }
    }
  }

  // For NW apps, store data in the same directory where NW stores application data
  if (this.filename &#x26;&#x26; options.nodeWebkitAppName) {
    console.log(&#x22;==================================================================&#x22;);
    console.log(&#x22;WARNING: The nodeWebkitAppName option is deprecated&#x22;);
    console.log(&#x22;To get the path to the directory where Node Webkit stores the data&#x22;);
    console.log(&#x22;for your app, use the internal nw.gui module like this&#x22;);
    console.log(&#x22;require(&#x27;nw.gui&#x27;).App.dataPath&#x22;);
    console.log(&#x22;See https://github.com/rogerwang/node-webkit/issues/500&#x22;);
    console.log(&#x22;==================================================================&#x22;);
    this.filename = Persistence.getNWAppFilename(options.nodeWebkitAppName, this.filename);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.persistence.ensureDirectoryExists" id="apidoc.element.nedb.persistence.ensureDirectoryExists">
        function <span class="apidocSignatureSpan">nedb.persistence.</span>ensureDirectoryExists
        <span class="apidocSignatureSpan">(dir, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ensureDirectoryExists = function (dir, cb) {
  var callback = cb || function () {}
    ;

  storage.mkdirp(dir, function (err) { return callback(err); });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};


/**
 * Ensure the workspace exists and the db datafile is empty
 */
module.exports.prepareDb = function (filename, cb) {
  Persistence.<span class="apidocCodeKeywordSpan">ensureDirectoryExists</span>(path.dirname(filename), function () {
    fs.exists(filename, function (exists) {
      if (exists) {
        fs.unlink(filename, cb);
      } else { return cb(); }
    });
  });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.persistence.getNWAppFilename" id="apidoc.element.nedb.persistence.getNWAppFilename">
        function <span class="apidocSignatureSpan">nedb.persistence.</span>getNWAppFilename
        <span class="apidocSignatureSpan">(appName, relativeFilename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getNWAppFilename = function (appName, relativeFilename) {
  var home;

  switch (process.platform) {
    case &#x27;win32&#x27;:
    case &#x27;win64&#x27;:
      home = process.env.LOCALAPPDATA || process.env.APPDATA;
      if (!home) { throw new Error(&#x22;Couldn&#x27;t find the base application data folder&#x22;); }
      home = path.join(home, appName);
      break;
    case &#x27;darwin&#x27;:
      home = process.env.HOME;
      if (!home) { throw new Error(&#x22;Couldn&#x27;t find the base application data directory&#x22;); }
      home = path.join(home, &#x27;Library&#x27;, &#x27;Application Support&#x27;, appName);
      break;
    case &#x27;linux&#x27;:
      home = process.env.HOME;
      if (!home) { throw new Error(&#x22;Couldn&#x27;t find the base application data directory&#x22;); }
      home = path.join(home, &#x27;.config&#x27;, appName);
      break;
    default:
      throw new Error(&#x22;Can&#x27;t use the Node Webkit relative path for platform &#x22; + process.platform);
      break;
  }

  return path.join(home, &#x27;nedb-data&#x27;, relativeFilename);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   console.log(&#x22;==================================================================&#x22;);
   console.log(&#x22;WARNING: The nodeWebkitAppName option is deprecated&#x22;);
   console.log(&#x22;To get the path to the directory where Node Webkit stores the data&#x22;);
   console.log(&#x22;for your app, use the internal nw.gui module like this&#x22;);
   console.log(&#x22;require(&#x27;nw.gui&#x27;).App.dataPath&#x22;);
   console.log(&#x22;See https://github.com/rogerwang/node-webkit/issues/500&#x22;);
   console.log(&#x22;==================================================================&#x22;);
   this.filename = Persistence.<span class="apidocCodeKeywordSpan">getNWAppFilename</span>(options.nodeWebkitAppName, this.filename
);
 }
};


/**
* Check if a directory exists and create it on the fly if it is not the case
* cb is optional, signature: err
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nedb.persistence.prototype" id="apidoc.module.nedb.persistence.prototype">module nedb.persistence.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.nedb.persistence.prototype.compactDatafile" id="apidoc.element.nedb.persistence.prototype.compactDatafile">
        function <span class="apidocSignatureSpan">nedb.persistence.prototype.</span>compactDatafile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compactDatafile = function () {
  this.db.executor.push({ this: this, fn: this.persistCachedDatabase, arguments: [] });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   , minInterval = 5000
   , realInterval = Math.max(interval || 0, minInterval)
   ;

 this.stopAutocompaction();

 this.autocompactionIntervalId = setInterval(function () {
   self.<span class="apidocCodeKeywordSpan">compactDatafile</span>();
 }, realInterval);
};


/**
* Stop autocompaction (do nothing if autocompaction was not running)
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.persistence.prototype.loadDatabase" id="apidoc.element.nedb.persistence.prototype.loadDatabase">
        function <span class="apidocSignatureSpan">nedb.persistence.prototype.</span>loadDatabase
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadDatabase = function (cb) {
  var callback = cb || function () {}
    , self = this
    ;

  self.db.resetIndexes();

  // In-memory only datastore
  if (self.inMemoryOnly) { return callback(null); }

  async.waterfall([
    function (cb) {
      Persistence.ensureDirectoryExists(path.dirname(self.filename), function (err) {
        storage.ensureDatafileIntegrity(self.filename, function (err) {
          storage.readFile(self.filename, &#x27;utf8&#x27;, function (err, rawData) {
            if (err) { return cb(err); }

            try {
              var treatedData = self.treatRawData(rawData);
            } catch (e) {
              return cb(e);
            }

            // Recreate all indexes in the datafile
            Object.keys(treatedData.indexes).forEach(function (key) {
              self.db.indexes[key] = new Index(treatedData.indexes[key]);
            });

            // Fill cached database (i.e. all indexes) with data
            try {
              self.db.resetIndexes(treatedData.data);
            } catch (e) {
              self.db.resetIndexes();   // Rollback any index which didn&#x27;t fail
              return cb(e);
            }

            self.db.persistence.persistCachedDatabase(cb);
          });
        });
      });
    }
  ], function (err) {
       if (err) { return callback(err); }

       self.db.executor.processBuffer();
       return callback(null);
     });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var Datastore = require(&#x27;nedb&#x27;)
, db = new Datastore();


// Type 2: Persistent datastore with manual loading
var Datastore = require(&#x27;nedb&#x27;)
, db = new Datastore({ filename: &#x27;path/to/datafile&#x27; });
db.<span class="apidocCodeKeywordSpan">loadDatabase</span>(function (err) {    // Callback is optional
// Now commands will be executed
});


// Type 3: Persistent datastore with automatic loading
var Datastore = require(&#x27;nedb&#x27;)
, db = new Datastore({ filename: &#x27;path/to/datafile&#x27;, autoload: true });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.persistence.prototype.persistCachedDatabase" id="apidoc.element.nedb.persistence.prototype.persistCachedDatabase">
        function <span class="apidocSignatureSpan">nedb.persistence.prototype.</span>persistCachedDatabase
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">persistCachedDatabase = function (cb) {
  var callback = cb || function () {}
    , toPersist = &#x27;&#x27;
    , self = this
    ;

  if (this.inMemoryOnly) { return callback(null); }

  this.db.getAllData().forEach(function (doc) {
    toPersist += self.afterSerialization(model.serialize(doc)) + &#x27;\n&#x27;;
  });
  Object.keys(this.db.indexes).forEach(function (fieldName) {
    if (fieldName != &#x22;_id&#x22;) {   // The special _id index is managed by datastore.js, the others need to be persisted
      toPersist += self.afterSerialization(model.serialize({ $$indexCreated: { fieldName: fieldName, unique: self.db.indexes[fieldName
].unique, sparse: self.db.indexes[fieldName].sparse }})) + &#x27;\n&#x27;;
    }
  });

  storage.crashSafeWriteFile(this.filename, toPersist, function (err) {
    if (err) { return callback(err); }
    self.db.emit(&#x27;compaction.done&#x27;);
    return callback(null);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          try {
            self.db.resetIndexes(treatedData.data);
          } catch (e) {
            self.db.resetIndexes();   // Rollback any index which didn&#x27;t fail
            return cb(e);
          }

          self.db.persistence.<span class="apidocCodeKeywordSpan">persistCachedDatabase</span>(cb);
        });
      });
    });
  }
], function (err) {
     if (err) { return callback(err); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.persistence.prototype.persistNewState" id="apidoc.element.nedb.persistence.prototype.persistNewState">
        function <span class="apidocSignatureSpan">nedb.persistence.prototype.</span>persistNewState
        <span class="apidocSignatureSpan">(newDocs, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">persistNewState = function (newDocs, cb) {
  var self = this
    , toPersist = &#x27;&#x27;
    , callback = cb || function () {}
    ;

  // In-memory only datastore
  if (self.inMemoryOnly) { return callback(null); }

  newDocs.forEach(function (doc) {
    toPersist += self.afterSerialization(model.serialize(doc)) + &#x27;\n&#x27;;
  });

  if (toPersist.length === 0) { return callback(null); }

  storage.appendFile(self.filename, toPersist, &#x27;utf8&#x27;, function (err) {
    return callback(err);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...



/**
 * Handle every persistence-related task
 * The interface Datastore expects to be implemented is
 * * Persistence.loadDatabase(callback) and callback has signature err
 * * Persistence.<span class="apidocCodeKeywordSpan">persistNewState</span>(newDocs, callback) where newDocs is an array of documents
 and callback has signature err
 */

var storage = require(&#x27;./storage&#x27;)
, path = require(&#x27;path&#x27;)
, model = require(&#x27;./model&#x27;)
, async = require(&#x27;async&#x27;)
, customUtils = require(&#x27;./customUtils&#x27;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.persistence.prototype.setAutocompactionInterval" id="apidoc.element.nedb.persistence.prototype.setAutocompactionInterval">
        function <span class="apidocSignatureSpan">nedb.persistence.prototype.</span>setAutocompactionInterval
        <span class="apidocSignatureSpan">(interval)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setAutocompactionInterval = function (interval) {
  var self = this
    , minInterval = 5000
    , realInterval = Math.max(interval || 0, minInterval)
    ;

  this.stopAutocompaction();

  this.autocompactionIntervalId = setInterval(function () {
    self.compactDatafile();
  }, realInterval);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

### Persistence
Under the hood, NeDB&#x27;s persistence uses an append-only format, meaning that all updates and deletes actually result in lines
 added at the end of the datafile, for performance reasons. The database is automatically compacted (i.e. put back in the one-line
-per-document format) every time you load each database within your application.

You can manually call the compaction function with `yourDatabase.persistence.compactDatafile` which takes no argument. It queues
 a compaction of the datafile in the executor, to be executed sequentially after all pending operations. The datastore will fire
 a `compaction.done` event once compaction is finished.

You can also set automatic compaction at regular intervals with `yourDatabase.persistence.<span class="apidocCodeKeywordSpan">setAutocompactionInterval
</span>(interval)`, `interval` in milliseconds (a minimum of 5s is enforced), and stop automatic compaction with `yourDatabase.persistence
.stopAutocompaction()`.

Keep in mind that compaction takes a bit of time (not too much: 130ms for 50k records on a typical development machine) and no other
 operation can happen when it does, so most projects actually don&#x27;t need to use it.

Compaction will also immediately remove any documents whose data line has become corrupted, assuming that the total percentage of
 all corrupted documents in that database still falls below the specified `corruptAlertThreshold` option&#x27;s value.

Durability works similarly to major databases: compaction forces the OS to physically flush data to disk, while appends to the data
 file do not (the OS is responsible for flushing the data). That guarantees that a server crash can never cause complete data loss
, while preserving performance. The worst that can happen is a crash between two syncs, causing a loss of all data between the two
 syncs. Usually syncs are 30 seconds appart so that&#x27;s at most 30 seconds of data. &#x3c;a href=&#x22;http://oldblog.antirez
.com/post/redis-persistence-demystified.html&#x22; target=&#x22;_blank&#x22;&#x3e;This post by Antirez on Redis persistence&#x3c
;/a&#x3e; explains this in more details, NeDB being very close to Redis AOF persistence with `appendfsync` option set to `no`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.persistence.prototype.stopAutocompaction" id="apidoc.element.nedb.persistence.prototype.stopAutocompaction">
        function <span class="apidocSignatureSpan">nedb.persistence.prototype.</span>stopAutocompaction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stopAutocompaction = function () {
  if (this.autocompactionIntervalId) { clearInterval(this.autocompactionIntervalId); }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

### Persistence
Under the hood, NeDB&#x27;s persistence uses an append-only format, meaning that all updates and deletes actually result in lines
 added at the end of the datafile, for performance reasons. The database is automatically compacted (i.e. put back in the one-line
-per-document format) every time you load each database within your application.

You can manually call the compaction function with `yourDatabase.persistence.compactDatafile` which takes no argument. It queues
 a compaction of the datafile in the executor, to be executed sequentially after all pending operations. The datastore will fire
 a `compaction.done` event once compaction is finished.

You can also set automatic compaction at regular intervals with `yourDatabase.persistence.setAutocompactionInterval(interval)`, `
interval` in milliseconds (a minimum of 5s is enforced), and stop automatic compaction with `yourDatabase.persistence.<span class
="apidocCodeKeywordSpan">stopAutocompaction</span>()`.

Keep in mind that compaction takes a bit of time (not too much: 130ms for 50k records on a typical development machine) and no other
 operation can happen when it does, so most projects actually don&#x27;t need to use it.

Compaction will also immediately remove any documents whose data line has become corrupted, assuming that the total percentage of
 all corrupted documents in that database still falls below the specified `corruptAlertThreshold` option&#x27;s value.

Durability works similarly to major databases: compaction forces the OS to physically flush data to disk, while appends to the data
 file do not (the OS is responsible for flushing the data). That guarantees that a server crash can never cause complete data loss
, while preserving performance. The worst that can happen is a crash between two syncs, causing a loss of all data between the two
 syncs. Usually syncs are 30 seconds appart so that&#x27;s at most 30 seconds of data. &#x3c;a href=&#x22;http://oldblog.antirez
.com/post/redis-persistence-demystified.html&#x22; target=&#x22;_blank&#x22;&#x3e;This post by Antirez on Redis persistence&#x3c
;/a&#x3e; explains this in more details, NeDB being very close to Redis AOF persistence with `appendfsync` option set to `no`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.persistence.prototype.treatRawData" id="apidoc.element.nedb.persistence.prototype.treatRawData">
        function <span class="apidocSignatureSpan">nedb.persistence.prototype.</span>treatRawData
        <span class="apidocSignatureSpan">(rawData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">treatRawData = function (rawData) {
  var data = rawData.split(&#x27;\n&#x27;)
    , dataById = {}
    , tdata = []
    , i
    , indexes = {}
    , corruptItems = -1   // Last line of every data file is usually blank so not really corrupt
    ;

  for (i = 0; i &#x3c; data.length; i += 1) {
    var doc;

    try {
      doc = model.deserialize(this.beforeDeserialization(data[i]));
      if (doc._id) {
        if (doc.$$deleted === true) {
          delete dataById[doc._id];
        } else {
          dataById[doc._id] = doc;
        }
      } else if (doc.$$indexCreated &#x26;&#x26; doc.$$indexCreated.fieldName != undefined) {
        indexes[doc.$$indexCreated.fieldName] = doc.$$indexCreated;
      } else if (typeof doc.$$indexRemoved === &#x22;string&#x22;) {
        delete indexes[doc.$$indexRemoved];
      }
    } catch (e) {
      corruptItems += 1;
    }
  }

  // A bit lenient on corruption
  if (data.length &#x3e; 0 &#x26;&#x26; corruptItems / data.length &#x3e; this.corruptAlertThreshold) {
    throw new Error(&#x22;More than &#x22; + Math.floor(100 * this.corruptAlertThreshold) + &#x22;% of the data file is corrupt, the wrong beforeDeserialization
 hook may be used. Cautiously refusing to start NeDB to prevent dataloss&#x22;);
  }

  Object.keys(dataById).forEach(function (k) {
    tdata.push(dataById[k]);
  });

  return { data: tdata, indexes: indexes };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    function (cb) {
      Persistence.ensureDirectoryExists(path.dirname(self.filename), function (err) {
        storage.ensureDatafileIntegrity(self.filename, function (err) {
          storage.readFile(self.filename, &#x27;utf8&#x27;, function (err, rawData) {
if (err) { return cb(err); }

try {
  var treatedData = self.<span class="apidocCodeKeywordSpan">treatRawData</span>(rawData);
} catch (e) {
  return cb(e);
}

// Recreate all indexes in the datafile
Object.keys(treatedData.indexes).forEach(function (key) {
  self.db.indexes[key] = new Index(treatedData.indexes[key]);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nedb.storage" id="apidoc.module.nedb.storage">module nedb.storage</a></h1>


    <h2>
        <a href="#apidoc.element.nedb.storage.appendFile" id="apidoc.element.nedb.storage.appendFile">
        function <span class="apidocSignatureSpan">nedb.storage.</span>appendFile
        <span class="apidocSignatureSpan">(path, data, options, callback_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">appendFile = function (path, data, options, callback_) {
  var callback = maybeCallback(arguments[arguments.length - 1]);

  if (!options || typeof options === &#x27;function&#x27;) {
    options = { encoding: &#x27;utf8&#x27;, mode: 0o666, flag: &#x27;a&#x27; };
  } else if (typeof options === &#x27;string&#x27;) {
    options = { encoding: options, mode: 0o666, flag: &#x27;a&#x27; };
  } else if (typeof options !== &#x27;object&#x27;) {
    throwOptionsError(options);
  }

  if (!options.flag)
    options = util._extend({ flag: &#x27;a&#x27; }, options);

  // force append behavior when using a supplied file descriptor
  if (isFd(path))
    options.flag = &#x27;a&#x27;;

  fs.writeFile(path, data, options, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

 newDocs.forEach(function (doc) {
   toPersist += self.afterSerialization(model.serialize(doc)) + &#x27;\n&#x27;;
 });

 if (toPersist.length === 0) { return callback(null); }

 storage.<span class="apidocCodeKeywordSpan">appendFile</span>(self.filename, toPersist, &#x27;utf8&#x27;, function (err) {
   return callback(err);
 });
};


/**
* From a database&#x27;s raw data, return the corresponding
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.storage.crashSafeWriteFile" id="apidoc.element.nedb.storage.crashSafeWriteFile">
        function <span class="apidocSignatureSpan">nedb.storage.</span>crashSafeWriteFile
        <span class="apidocSignatureSpan">(filename, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">crashSafeWriteFile = function (filename, data, cb) {
  var callback = cb || function () {}
    , tempFilename = filename + &#x27;~&#x27;;

  async.waterfall([
    async.apply(storage.flushToStorage, { filename: path.dirname(filename), isDir: true })
  , function (cb) {
      storage.exists(filename, function (exists) {
        if (exists) {
          storage.flushToStorage(filename, function (err) { return cb(err); });
        } else {
          return cb();
        }
      });
    }
  , function (cb) {
      storage.writeFile(tempFilename, data, function (err) { return cb(err); });
    }
  , async.apply(storage.flushToStorage, tempFilename)
  , function (cb) {
      storage.rename(tempFilename, filename, function (err) { return cb(err); });
    }
  , async.apply(storage.flushToStorage, { filename: path.dirname(filename), isDir: true })
  ], function (err) { return callback(err); })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  });
  Object.keys(this.db.indexes).forEach(function (fieldName) {
    if (fieldName != &#x22;_id&#x22;) {   // The special _id index is managed by datastore.js, the others need to be persisted
      toPersist += self.afterSerialization(model.serialize({ $$indexCreated: { fieldName: fieldName, unique: self.db.indexes[fieldName
].unique, sparse: self.db.indexes[fieldName].sparse }})) + &#x27;\n&#x27;;
    }
  });

  storage.<span class="apidocCodeKeywordSpan">crashSafeWriteFile</span>(this.filename, toPersist, function (err) {
    if (err) { return callback(err); }
    self.db.emit(&#x27;compaction.done&#x27;);
    return callback(null);
  });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.storage.ensureDatafileIntegrity" id="apidoc.element.nedb.storage.ensureDatafileIntegrity">
        function <span class="apidocSignatureSpan">nedb.storage.</span>ensureDatafileIntegrity
        <span class="apidocSignatureSpan">(filename, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ensureDatafileIntegrity = function (filename, callback) {
  var tempFilename = filename + &#x27;~&#x27;;

  storage.exists(filename, function (filenameExists) {
    // Write was successful
    if (filenameExists) { return callback(null); }

    storage.exists(tempFilename, function (oldFilenameExists) {
      // New database
      if (!oldFilenameExists) {
        return storage.writeFile(filename, &#x27;&#x27;, &#x27;utf8&#x27;, function (err) { callback(err); });
      }

      // Write failed, use old version
      storage.rename(tempFilename, filename, function (err) { return callback(err); });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  // In-memory only datastore
  if (self.inMemoryOnly) { return callback(null); }

  async.waterfall([
    function (cb) {
      Persistence.ensureDirectoryExists(path.dirname(self.filename), function (err) {
        storage.<span class="apidocCodeKeywordSpan">ensureDatafileIntegrity</span>(self.filename, function (err) {
          storage.readFile(self.filename, &#x27;utf8&#x27;, function (err, rawData) {
if (err) { return cb(err); }

try {
  var treatedData = self.treatRawData(rawData);
} catch (e) {
  return cb(e);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.storage.ensureFileDoesntExist" id="apidoc.element.nedb.storage.ensureFileDoesntExist">
        function <span class="apidocSignatureSpan">nedb.storage.</span>ensureFileDoesntExist
        <span class="apidocSignatureSpan">(file, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ensureFileDoesntExist = function (file, callback) {
  storage.exists(file, function (exists) {
    if (!exists) { return callback(null); }

    storage.unlink(file, function (err) { return callback(err); });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.storage.exists" id="apidoc.element.nedb.storage.exists">
        function <span class="apidocSignatureSpan">nedb.storage.</span>exists
        <span class="apidocSignatureSpan">(path, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exists = function (path, callback) {
  if (!nullCheck(path, cb)) return;
  var req = new FSReqWrap();
  req.oncomplete = cb;
  binding.stat(pathModule._makeLong(path), req);
  function cb(err, stats) {
    if (callback) callback(err ? false : true);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


/**
 * Ensure the workspace exists and the db datafile is empty
 */
module.exports.prepareDb = function (filename, cb) {
  Persistence.ensureDirectoryExists(path.dirname(filename), function () {
    fs.<span class="apidocCodeKeywordSpan">exists</span>(filename, function (exists) {
      if (exists) {
        fs.unlink(filename, cb);
      } else { return cb(); }
    });
  });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.storage.flushToStorage" id="apidoc.element.nedb.storage.flushToStorage">
        function <span class="apidocSignatureSpan">nedb.storage.</span>flushToStorage
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flushToStorage = function (options, callback) {
  var filename, flags;
  if (typeof options === &#x27;string&#x27;) {
    filename = options;
    flags = &#x27;r+&#x27;;
  } else {
    filename = options.filename;
    flags = options.isDir ? &#x27;r&#x27; : &#x27;r+&#x27;;
  }

  // Windows can&#x27;t fsync (FlushFileBuffers) directories. We can live with this as it cannot cause 100% dataloss
  // except in the very rare event of the first time database is loaded and a crash happens
  if (flags === &#x27;r&#x27; &#x26;&#x26; (process.platform === &#x27;win32&#x27; || process.platform === &#x27;win64&#x27;)) { return callback(null); }

  fs.open(filename, flags, function (err, fd) {
    if (err) { return callback(err); }
    fs.fsync(fd, function (errFS) {
      fs.close(fd, function (errC) {
        if (errFS || errC) {
          var e = new Error(&#x27;Failed to flush to storage&#x27;);
          e.errorOnFsync = errFS;
          e.errorOnClose = errC;
          return callback(e);
        } else {
          return callback(null);
        }
      });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  , tempFilename = filename + &#x27;~&#x27;;

async.waterfall([
  async.apply(storage.flushToStorage, { filename: path.dirname(filename), isDir: true })
, function (cb) {
    storage.exists(filename, function (exists) {
      if (exists) {
        storage.<span class="apidocCodeKeywordSpan">flushToStorage</span>(filename, function (err) { return cb(err); });
      } else {
        return cb();
      }
    });
  }
, function (cb) {
    storage.writeFile(tempFilename, data, function (err) { return cb(err); });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.storage.mkdirp" id="apidoc.element.nedb.storage.mkdirp">
        function <span class="apidocSignatureSpan">nedb.storage.</span>mkdirp
        <span class="apidocSignatureSpan">(p, opts, f, made)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mkdirP(p, opts, f, made) {
    if (typeof opts === &#x27;function&#x27;) {
        f = opts;
        opts = {};
    }
    else if (!opts || typeof opts !== &#x27;object&#x27;) {
        opts = { mode: opts };
    }

    var mode = opts.mode;
    var xfs = opts.fs || fs;

    if (mode === undefined) {
        mode = _0777 &#x26; (~process.umask());
    }
    if (!made) made = null;

    var cb = f || function () {};
    p = path.resolve(p);

    xfs.mkdir(p, mode, function (er) {
        if (!er) {
            made = made || p;
            return cb(null, made);
        }
        switch (er.code) {
            case &#x27;ENOENT&#x27;:
                mkdirP(path.dirname(p), opts, function (er, made) {
                    if (er) cb(er, made);
                    else mkdirP(p, opts, cb, made);
                });
                break;

            // In the case of any other error, just see if there&#x27;s a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
            default:
                xfs.stat(p, function (er2, stat) {
                    // if the stat fails, then that&#x27;s super weird.
                    // let the original error be the failure reason.
                    if (er2 || !stat.isDirectory()) cb(er, made)
                    else cb(null, made);
                });
                break;
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Check if a directory exists and create it on the fly if it is not the case
* cb is optional, signature: err
*/
Persistence.ensureDirectoryExists = function (dir, cb) {
 var callback = cb || function () {}
   ;

 storage.<span class="apidocCodeKeywordSpan">mkdirp</span>(dir, function (err) { return callback(err); });
};




/**
* Return the path the datafile if the given filename is relative to the directory where Node Webkit stores
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.storage.readFile" id="apidoc.element.nedb.storage.readFile">
        function <span class="apidocSignatureSpan">nedb.storage.</span>readFile
        <span class="apidocSignatureSpan">(path, options, callback_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readFile = function (path, options, callback_) {
  var callback = maybeCallback(arguments[arguments.length - 1]);

  if (!options || typeof options === &#x27;function&#x27;) {
    options = { encoding: null, flag: &#x27;r&#x27; };
  } else if (typeof options === &#x27;string&#x27;) {
    options = { encoding: options, flag: &#x27;r&#x27; };
  } else if (typeof options !== &#x27;object&#x27;) {
    throwOptionsError(options);
  }

  var encoding = options.encoding;
  assertEncoding(encoding);

  var flag = options.flag || &#x27;r&#x27;;

  if (!nullCheck(path, callback))
    return;

  var context = new ReadFileContext(callback, encoding);
  context.isUserFd = isFd(path); // file descriptor ownership
  var req = new FSReqWrap();
  req.context = context;
  req.oncomplete = readFileAfterOpen;

  if (context.isUserFd) {
    process.nextTick(function() {
      req.oncomplete(null, path);
    });
    return;
  }

  binding.open(pathModule._makeLong(path),
               stringToFlags(flag),
               0o666,
               req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // In-memory only datastore
  if (self.inMemoryOnly) { return callback(null); }

  async.waterfall([
    function (cb) {
      Persistence.ensureDirectoryExists(path.dirname(self.filename), function (err) {
        storage.ensureDatafileIntegrity(self.filename, function (err) {
          storage.<span class="apidocCodeKeywordSpan">readFile</span>(self.filename, &#x27;utf8&#x27;, function (err, rawData) {
if (err) { return cb(err); }

try {
  var treatedData = self.treatRawData(rawData);
} catch (e) {
  return cb(e);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.storage.rename" id="apidoc.element.nedb.storage.rename">
        function <span class="apidocSignatureSpan">nedb.storage.</span>rename
        <span class="apidocSignatureSpan">(oldPath, newPath, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rename = function (oldPath, newPath, callback) {
  callback = makeCallback(callback);
  if (!nullCheck(oldPath, callback)) return;
  if (!nullCheck(newPath, callback)) return;
  var req = new FSReqWrap();
  req.oncomplete = callback;
  binding.rename(pathModule._makeLong(oldPath),
                 pathModule._makeLong(newPath),
                 req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      });
    }
  , function (cb) {
      storage.writeFile(tempFilename, data, function (err) { return cb(err); });
    }
  , async.apply(storage.flushToStorage, tempFilename)
  , function (cb) {
      storage.<span class="apidocCodeKeywordSpan">rename</span>(tempFilename, filename, function (err) { return cb(err); });
    }
  , async.apply(storage.flushToStorage, { filename: path.dirname(filename), isDir: true })
  ], function (err) { return callback(err); })
};


/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.storage.unlink" id="apidoc.element.nedb.storage.unlink">
        function <span class="apidocSignatureSpan">nedb.storage.</span>unlink
        <span class="apidocSignatureSpan">(path, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unlink = function (path, callback) {
  callback = makeCallback(callback);
  if (!nullCheck(path, callback)) return;
  var req = new FSReqWrap();
  req.oncomplete = callback;
  binding.unlink(pathModule._makeLong(path), req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Ensure the workspace exists and the db datafile is empty
 */
module.exports.prepareDb = function (filename, cb) {
  Persistence.ensureDirectoryExists(path.dirname(filename), function () {
    fs.exists(filename, function (exists) {
      if (exists) {
        fs.<span class="apidocCodeKeywordSpan">unlink</span>(filename, cb);
      } else { return cb(); }
    });
  });
};


/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nedb.storage.writeFile" id="apidoc.element.nedb.storage.writeFile">
        function <span class="apidocSignatureSpan">nedb.storage.</span>writeFile
        <span class="apidocSignatureSpan">(path, data, options, callback_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeFile = function (path, data, options, callback_) {
  var callback = maybeCallback(arguments[arguments.length - 1]);

  if (!options || typeof options === &#x27;function&#x27;) {
    options = { encoding: &#x27;utf8&#x27;, mode: 0o666, flag: &#x27;w&#x27; };
  } else if (typeof options === &#x27;string&#x27;) {
    options = { encoding: options, mode: 0o666, flag: &#x27;w&#x27; };
  } else if (typeof options !== &#x27;object&#x27;) {
    throwOptionsError(options);
  }

  assertEncoding(options.encoding);

  var flag = options.flag || &#x27;w&#x27;;

  if (isFd(path)) {
    writeFd(path, true);
    return;
  }

  fs.open(path, flag, options.mode, function(openErr, fd) {
    if (openErr) {
      callback(openErr);
    } else {
      writeFd(fd, false);
    }
  });

  function writeFd(fd, isUserFd) {
    var buffer = (data instanceof Buffer) ?
        data : Buffer.from(&#x27;&#x27; + data, options.encoding || &#x27;utf8&#x27;);
    var position = /a/.test(flag) ? null : 0;

    writeAll(fd, isUserFd, buffer, 0, buffer.length, position, callback);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        storage.flushToStorage(filename, function (err) { return cb(err); });
      } else {
        return cb();
      }
    });
  }
, function (cb) {
    storage.<span class="apidocCodeKeywordSpan">writeFile</span>(tempFilename, data, function (err) { return cb(err); });
  }
, async.apply(storage.flushToStorage, tempFilename)
, function (cb) {
    storage.rename(tempFilename, filename, function (err) { return cb(err); });
  }
, async.apply(storage.flushToStorage, { filename: path.dirname(filename), isDir: true })
], function (err) { return callback(err); })
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
